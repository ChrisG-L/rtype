def builderAPI

// Couleurs Discord (d√©cimal)
def COLOR_GREEN = 3066993
def COLOR_RED = 15158332
def COLOR_YELLOW = 16776960
def COLOR_GRAY = 9807270

/**
 * Envoie une notification Discord via webhook
 * @param title Titre de l'embed
 * @param message Description du message
 * @param color Couleur de l'embed (d√©cimal)
 */
def notifyDiscord(Map params) {
    def title = params.title ?: "Jenkins Notification"
    def message = params.message ?: ""
    def color = params.color ?: COLOR_GREEN

    if (!env.DISCORD_WEBHOOK_URL) {
        echo "‚ö†Ô∏è DISCORD_WEBHOOK_URL non configur√©, notification ignor√©e"
        return
    }

    def timestamp = new Date().format("yyyy-MM-dd'T'HH:mm:ss'Z'", TimeZone.getTimeZone('UTC'))

    // √âchapper les caract√®res sp√©ciaux pour JSON
    def safeTitle = title.replaceAll('"', '\\\\"')
    def safeMessage = message.replaceAll('"', '\\\\"')

    def payload = """{"embeds":[{"title":"${safeTitle}","description":"${safeMessage}","color":${color},"timestamp":"${timestamp}","footer":{"text":"Jenkins CI/CD"}}]}"""

    try {
        // √âcrire le payload dans un fichier temporaire pour √©viter les probl√®mes d'√©chappement
        writeFile file: 'discord_payload.json', text: payload

        // Utiliser la variable shell $DISCORD_WEBHOOK_URL (pas d'interpolation Groovy)
        sh(script: '''
            curl -s -X POST "$DISCORD_WEBHOOK_URL" \
                -H 'Content-Type: application/json' \
                -d @discord_payload.json
            rm -f discord_payload.json
        ''', returnStatus: true)
        echo "‚úÖ Notification Discord envoy√©e: ${title}"
    } catch (Exception e) {
        echo "‚ö†Ô∏è Erreur notification Discord: ${e.message}"
    }
}

pipeline {
    agent any

    /* // D√©clencheur pour surveiller les changements dans le SCM toutes les 3 minutes
    triggers {
        pollSCM("H/3 * * * *")
    } */

    // Options globales pour le pipeline
    options {
        timeout(time: 3, unit: 'HOURS')
        buildDiscarder(logRotator(numToKeepStr: '10'))
    }

    environment {
        BUILDER_HOST = "localhost"
        BUILDER_PORT = "8082"
        WORKSPACE_ID_LINUX = "build_${BUILD_NUMBER}_linux"
        WORKSPACE_ID_WINDOWS = "build_${BUILD_NUMBER}_windows"
        DISCORD_WEBHOOK_URL = credentials('discord-webhook-url')
    }

    stages {
        stage('Checkout') {
            steps {
                echo 'üì• R√©cup√©ration du code source...'
                checkout scm

                // G√©n√©rer version_history.txt pour le syst√®me de version checking
                echo 'üìã G√©n√©ration de version_history.txt...'
                sh 'git log --format="%h" -n 50 > version_history.txt'
                sh 'echo "Version history generated with $(wc -l < version_history.txt) entries"'
            }
        }

        stage('üîî Notify Build Started') {
            steps {
                script {
                    def commitInfo = sh(script: "git log -1 --pretty=format:'%h - %s (%an)'", returnStdout: true).trim()
                    def branchName = env.BRANCH_NAME ?: sh(script: "git rev-parse --abbrev-ref HEAD", returnStdout: true).trim()

                    notifyDiscord(
                        title: "üî® Build #${BUILD_NUMBER} D√©marr√©",
                        message: "**Branche:** ${branchName}\\n**Commit:** ${commitInfo}\\n**Job:** [${JOB_NAME}](${BUILD_URL})",
                        color: 16776960  // Jaune
                    )
                }
            }
        }

        stage('üîå Initialize Builder API') {
            steps {
                script {
                    builderAPI = load('ci_cd/jenkins/BuilderAPI.groovy')
                    def api = builderAPI.create(this, env.BUILDER_HOST, env.BUILDER_PORT.toInteger())

                    // V√©rifier que le builder est accessible
                    if (!api.healthCheck()) {
                        error("‚ùå Le builder permanent n'est pas accessible. Lancez d'abord le job d'initialisation (Jenkinsfile.init).")
                    }
                }
            }
        }

        stage('üìã Create Workspaces') {
            parallel {
                stage('Create Linux Workspace') {
                    steps {
                        script {
                            echo "üìã Cr√©ation du workspace Linux ${env.WORKSPACE_ID_LINUX}..."

                            def createResponse = sh(
                                script: """
                                    curl -s -f -X POST http://${env.BUILDER_HOST}:${env.BUILDER_PORT}/workspace/create \
                                        -H 'Content-Type: application/json' \
                                        -d '{"build_number": "${env.BUILD_NUMBER}_linux"}'
                                """,
                                returnStdout: true
                            ).trim()

                            echo "‚úÖ Workspace Linux cr√©√©: ${createResponse}"
                        }
                    }
                }
                stage('Create Windows Workspace') {
                    steps {
                        script {
                            echo "üìã Cr√©ation du workspace Windows ${env.WORKSPACE_ID_WINDOWS}..."

                            def createResponse = sh(
                                script: """
                                    curl -s -f -X POST http://${env.BUILDER_HOST}:${env.BUILDER_PORT}/workspace/create \
                                        -H 'Content-Type: application/json' \
                                        -d '{"build_number": "${env.BUILD_NUMBER}_windows"}'
                                """,
                                returnStdout: true
                            ).trim()

                            echo "‚úÖ Workspace Windows cr√©√©: ${createResponse}"
                        }
                    }
                }
            }
        }

        stage('üì§ Upload Source Code') {
            parallel {
                stage('Upload to Linux Workspace') {
                    steps {
                        script {
                            echo "üì§ Upload du code source vers workspace Linux via rsync..."

                            sh """
                                rsync -avz --delete \
                                    --exclude='.git' \
                                    --exclude='build/*' \
                                    --exclude='buildLinux/*' \
                                    --exclude='buildWin/*' \
                                    --exclude='buildMac/*' \
                                    --exclude='cmake-build-*' \
                                    --exclude='*.o' \
                                    --exclude='*.a' \
                                    --exclude='.gitignore' \
                                    --exclude='third_party/vcpkg/.git' \
                                    --exclude='artifacts' \
                                    ${WORKSPACE}/ \
                                    rsync://${env.BUILDER_HOST}:873/workspace/${env.WORKSPACE_ID_LINUX}/
                            """

                            echo "‚úÖ Code source upload√© vers workspace Linux"
                        }
                    }
                }
                stage('Upload to Windows Workspace') {
                    steps {
                        script {
                            echo "üì§ Upload du code source vers workspace Windows via rsync..."

                            sh """
                                rsync -avz --delete \
                                    --exclude='.git' \
                                    --exclude='build/*' \
                                    --exclude='buildLinux/*' \
                                    --exclude='buildWin/*' \
                                    --exclude='buildMac/*' \
                                    --exclude='cmake-build-*' \
                                    --exclude='*.o' \
                                    --exclude='*.a' \
                                    --exclude='.gitignore' \
                                    --exclude='third_party/vcpkg/.git' \
                                    --exclude='artifacts' \
                                    ${WORKSPACE}/ \
                                    rsync://${env.BUILDER_HOST}:873/workspace/${env.WORKSPACE_ID_WINDOWS}/
                            """

                            echo "‚úÖ Code source upload√© vers workspace Windows"
                        }
                    }
                }
            }
        }

        stage('üèóÔ∏è  Build Matrix (Linux + Windows)') {
            parallel {
                stage('üêß Linux Build') {
                    stages {
                        stage('üî® Build Linux') {
                            steps {
                                // catchError permet de continuer m√™me si ce stage √©choue
                                // Les artifacts partiels pourront √™tre r√©cup√©r√©s
                                catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                                    script {
                                        echo 'üî® [LINUX] Configuration CMake et vcpkg...'

                                        def api = builderAPI.create(this, env.BUILDER_HOST, env.BUILDER_PORT.toInteger())

                                        // Lancer le build dans le workspace Linux (plateforme linux par d√©faut)
                                        def jobId = api.runInWorkspace(env.WORKSPACE_ID_LINUX, 'build')

                                        echo "[LINUX] Job cr√©√©: ${jobId}"

                                        // Attendre la fin du build
                                        api.waitForJob(jobId, 10, 7200)

                                        echo "‚úÖ [LINUX] Build termin√© avec succ√®s"
                                    }
                                }
                            }
                        }

                        stage('üîß Compile Linux') {
                            steps {
                                catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                                    script {
                                        echo 'üîß [LINUX] Compilation du projet...'

                                        def api = builderAPI.create(this, env.BUILDER_HOST, env.BUILDER_PORT.toInteger())

                                        // Lancer la compilation dans le workspace Linux
                                        def jobId = api.runInWorkspace(env.WORKSPACE_ID_LINUX, 'compile')

                                        echo "[LINUX] Job cr√©√©: ${jobId}"

                                        // Attendre la fin de la compilation
                                        api.waitForJob(jobId, 10, 7200)

                                        echo "‚úÖ [LINUX] Compilation termin√©e avec succ√®s"
                                    }
                                }
                            }
                        }
                    }
                }

                stage('ü™ü Windows Build (cross-compilation)') {
                    stages {
                        stage('üî® Build Windows') {
                            steps {
                                catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                                    script {
                                        echo 'üî® [WINDOWS] Configuration CMake et vcpkg avec MinGW...'

                                        def api = builderAPI.create(this, env.BUILDER_HOST, env.BUILDER_PORT.toInteger())

                                        // Lancer le build Windows dans le workspace Windows avec --platform=windows
                                        def jobId = api.runInWorkspace(env.WORKSPACE_ID_WINDOWS, 'build', '--platform=windows')

                                        echo "[WINDOWS] Job cr√©√©: ${jobId}"

                                        // Attendre la fin du build
                                        api.waitForJob(jobId, 10, 7200)

                                        echo "‚úÖ [WINDOWS] Build termin√© avec succ√®s"
                                    }
                                }
                            }
                        }

                        stage('üîß Compile Windows') {
                            steps {
                                catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                                    script {
                                        echo 'üîß [WINDOWS] Compilation du projet avec MinGW...'

                                        def api = builderAPI.create(this, env.BUILDER_HOST, env.BUILDER_PORT.toInteger())

                                        // Lancer la compilation dans le workspace Windows
                                        def jobId = api.runInWorkspace(env.WORKSPACE_ID_WINDOWS, 'compile', '--platform=windows')

                                        echo "[WINDOWS] Job cr√©√©: ${jobId}"

                                        // Attendre la fin de la compilation
                                        api.waitForJob(jobId, 10, 7200)

                                        echo "‚úÖ [WINDOWS] Compilation termin√©e avec succ√®s"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        stage('üß™ Run Linux Test') {
            // Tests uniquement sur Linux (Windows = cross-compile, non ex√©cutable)
            steps {
                catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {
                    script {
                        echo 'üß™ Ex√©cution des tests sur Linux...'

                        def api = builderAPI.create(this, env.BUILDER_HOST, env.BUILDER_PORT.toInteger())

                        // Lancer les tests dans le workspace Linux
                        def jobId = api.runInWorkspace(env.WORKSPACE_ID_LINUX, 'test')

                        echo "[LINUX] Job cr√©√©: ${jobId}"

                        // Attendre la fin des tests
                        api.waitForJob(jobId, 10, 7200)

                        echo "‚úÖ [LINUX] Tests ex√©cut√©s avec succ√®s"
                    }
                }
            }
        }

        stage('üöÄ Deploy to Production') {
            when {
                branch 'main'
            }
            steps {
                catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {
                    script {
                        echo 'üöÄ D√©ploiement automatique sur le serveur de production...'

                        // Attendre que les artifacts soient r√©cup√©r√©s
                        def api = builderAPI.create(this, env.BUILDER_HOST, env.BUILDER_PORT.toInteger())

                        // T√©l√©charger l'artifact serveur Linux localement
                        def artifactPath = "${WORKSPACE}/artifacts/${env.WORKSPACE_ID_LINUX}"
                        def serverBinary = "${artifactPath}/server/linux/rtype_server"

                        // V√©rifier que le binaire existe
                        if (!fileExists(serverBinary)) {
                            // T√©l√©charger les artifacts si pas encore fait
                            api.downloadArtifacts(
                                env.BUILDER_HOST,
                                env.WORKSPACE_ID_LINUX,
                                artifactPath
                            )
                        }

                        if (!fileExists(serverBinary)) {
                            error("‚ùå Binaire serveur non trouv√©: ${serverBinary}")
                        }

                        echo "üì¶ Binaire trouv√©: ${serverBinary}"

                        // Appeler le service de d√©ploiement local
                        def deployResponse = sh(
                            script: """
                                curl -s -f -X POST http://127.0.0.1:8081/deploy \
                                    -H 'Content-Type: application/json' \
                                    -d '{"source": "${serverBinary}"}'
                            """,
                            returnStdout: true
                        ).trim()

                        echo "R√©ponse du d√©ploiement: ${deployResponse}"

                        // V√©rifier le statut
                        def statusResponse = sh(
                            script: "curl -s http://127.0.0.1:8081/status",
                            returnStdout: true
                        ).trim()

                        def status = api.parseJson(statusResponse)

                        if (status.active) {
                            echo "‚úÖ Serveur d√©ploy√© et actif (PID: ${status.pid})"
                        } else {
                            error("‚ùå Le serveur n'est pas actif apr√®s d√©ploiement")
                        }
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                // R√©cup√©ration des artifacts AVANT le nettoyage (m√™me en cas d'√©chec)
                echo 'üì¶ R√©cup√©ration des artefacts (m√™me en cas d\'√©chec)...'

                try {
                    def api = builderAPI.create(this, env.BUILDER_HOST, env.BUILDER_PORT.toInteger())

                    // T√©l√©charger les artefacts Linux
                    try {
                        def artifactPathLinux = "${WORKSPACE}/artifacts/${env.WORKSPACE_ID_LINUX}"
                        def countLinux = api.downloadArtifacts(
                            env.BUILDER_HOST,
                            env.WORKSPACE_ID_LINUX,
                            artifactPathLinux
                        )
                        echo "‚úÖ ${countLinux} artefact(s) Linux t√©l√©charg√©(s)"
                    } catch (Exception e) {
                        echo "‚ö†Ô∏è  Impossible de r√©cup√©rer les artefacts Linux: ${e.message}"
                    }

                    // T√©l√©charger les artefacts Windows
                    try {
                        def artifactPathWindows = "${WORKSPACE}/artifacts/${env.WORKSPACE_ID_WINDOWS}"
                        def countWindows = api.downloadArtifacts(
                            env.BUILDER_HOST,
                            env.WORKSPACE_ID_WINDOWS,
                            artifactPathWindows
                        )
                        echo "‚úÖ ${countWindows} artefact(s) Windows t√©l√©charg√©(s)"
                    } catch (Exception e) {
                        echo "‚ö†Ô∏è  Impossible de r√©cup√©rer les artefacts Windows: ${e.message}"
                    }

                    // Copier version_history.txt et generate_dev_certs.sh dans les artifacts
                    echo "üìã Ajout des fichiers utilitaires aux artifacts..."
                    sh """
                        # Trouver les dossiers artifacts (server/linux, server/windows, client/linux, client/windows)
                        LINUX_SERVER_DIR=\$(find ${WORKSPACE}/artifacts -path "*/server/linux" -type d 2>/dev/null | head -1)
                        LINUX_CLIENT_DIR=\$(find ${WORKSPACE}/artifacts -path "*/client/linux" -type d 2>/dev/null | head -1)
                        WIN_SERVER_DIR=\$(find ${WORKSPACE}/artifacts -path "*/server/windows" -type d 2>/dev/null | head -1)
                        WIN_CLIENT_DIR=\$(find ${WORKSPACE}/artifacts -path "*/client/windows" -type d 2>/dev/null | head -1)

                        # Copier version_history.txt
                        if [ -f "${WORKSPACE}/version_history.txt" ]; then
                            for dir in "\$LINUX_SERVER_DIR" "\$LINUX_CLIENT_DIR" "\$WIN_SERVER_DIR" "\$WIN_CLIENT_DIR"; do
                                if [ -n "\$dir" ] && [ -d "\$dir" ]; then
                                    cp ${WORKSPACE}/version_history.txt \$dir/
                                    echo "‚úÖ version_history.txt copi√© vers \$dir"
                                fi
                            done
                        else
                            echo "‚ö†Ô∏è  version_history.txt non trouv√©"
                        fi

                        # Copier generate_dev_certs.sh (uniquement pour server)
                        if [ -f "${WORKSPACE}/scripts/generate_dev_certs.sh" ]; then
                            for dir in "\$LINUX_SERVER_DIR" "\$WIN_SERVER_DIR"; do
                                if [ -n "\$dir" ] && [ -d "\$dir" ]; then
                                    cp ${WORKSPACE}/scripts/generate_dev_certs.sh \$dir/
                                    echo "‚úÖ generate_dev_certs.sh copi√© vers \$dir"
                                fi
                            done
                        else
                            echo "‚ö†Ô∏è  generate_dev_certs.sh non trouv√©"
                        fi

                        # Copier run-client-standalone.sh (uniquement pour client Linux)
                        if [ -f "${WORKSPACE}/scripts/run-client-standalone.sh" ]; then
                            if [ -n "\$LINUX_CLIENT_DIR" ] && [ -d "\$LINUX_CLIENT_DIR" ]; then
                                cp ${WORKSPACE}/scripts/run-client-standalone.sh \$LINUX_CLIENT_DIR/run-client.sh
                                chmod +x \$LINUX_CLIENT_DIR/run-client.sh
                                echo "‚úÖ run-client.sh copi√© vers \$LINUX_CLIENT_DIR"
                            fi
                        else
                            echo "‚ö†Ô∏è  run-client-standalone.sh non trouv√©"
                        fi
                    """

                    // Archiver tous les artefacts disponibles (Linux + Windows)
                    archiveArtifacts artifacts: "artifacts/**/*",
                                    fingerprint: true,
                                    allowEmptyArchive: true  // Ne pas √©chouer si aucun artifact

                    echo "‚úÖ Artefacts archiv√©s dans Jenkins"

                } catch (Exception e) {
                    echo "‚ö†Ô∏è  Erreur lors de la r√©cup√©ration des artefacts: ${e.message}"
                }

                // Nettoyage des workspaces APR√àS la r√©cup√©ration
                echo 'üßπ Nettoyage des workspaces...'

                sh """
                    curl -s -X DELETE http://${env.BUILDER_HOST}:${env.BUILDER_PORT}/workspace/${env.WORKSPACE_ID_LINUX} || true
                    curl -s -X DELETE http://${env.BUILDER_HOST}:${env.BUILDER_PORT}/workspace/${env.WORKSPACE_ID_WINDOWS} || true
                """

                echo '‚úÖ Workspaces nettoy√©s'
                echo 'üèÅ Pipeline termin√©'
            }
        }
        success {
            script {
                echo '‚úÖ Build r√©ussi !'

                def duration = currentBuild.durationString.replace(' and counting', '')
                def branchName = env.BRANCH_NAME ?: sh(script: "git rev-parse --abbrev-ref HEAD", returnStdout: true).trim()

                notifyDiscord(
                    title: "‚úÖ Build #${BUILD_NUMBER} R√©ussi",
                    message: "**Branche:** ${branchName}\\n**Dur√©e:** ${duration}\\n**Job:** [Voir les d√©tails](${BUILD_URL})",
                    color: 3066993  // Vert
                )
            }
        }
        failure {
            script {
                echo '‚ùå Build √©chou√© !'

                def duration = currentBuild.durationString.replace(' and counting', '')
                def branchName = env.BRANCH_NAME ?: sh(script: "git rev-parse --abbrev-ref HEAD", returnStdout: true).trim()

                notifyDiscord(
                    title: "‚ùå Build #${BUILD_NUMBER} √âchou√©",
                    message: "**Branche:** ${branchName}\\n**Dur√©e:** ${duration}\\n**Job:** [Voir les logs](${BUILD_URL}console)",
                    color: 15158332  // Rouge
                )
            }
        }
    }
}