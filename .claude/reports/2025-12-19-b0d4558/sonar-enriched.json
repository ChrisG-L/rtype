{
  "agent": "sonar",
  "timestamp": "2025-12-19T14:32:00Z",
  "total_issues": 5,
  "enriched_issues": 5,
  "agentdb_queries": {
    "file_context": {"status": "not_indexed", "count": 0, "not_indexed": 2},
    "patterns": {"status": "ok", "count": 0, "note": "No patterns defined in project"}
  },
  "issues": [
    {
      "id": "SONAR-001",
      "source": ["sonarqube"],
      "title": "Empty compound statement without explanation",
      "severity": "Major",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/src/network/UDPClient.cpp",
      "line": 169,
      "rule": "cpp:S108",
      "effort": "5min",
      "agentdb_context": {
        "module": "client/network",
        "is_critical": true,
        "patterns_violated": [],
        "adr_applicable": null,
        "status": "NOT_INDEXED"
      },
      "where": "## Localisation\n\nLe probleme se trouve dans `src/client/src/network/UDPClient.cpp` a la ligne 169.\n\n```cpp\n// Ligne 165-174 - Methode isConnected et getLocalPlayerId\nbool UDPClient::isConnected() const\n{\n    return _connected && _socket.is_open();\n}\n\nstd::optional<uint8_t> UDPClient::getLocalPlayerId() const\n{\n    std::lock_guard<std::mutex> lock(_playersMutex);\n    return _localPlayerId;\n}\n```\n\n### Contexte du fichier\n\n**Module** : client/network\n**Role** : Client UDP principal pour la communication reseau avec le serveur de jeu. Ce fichier gere toute la logique de connexion/deconnexion, l'envoi de commandes (mouvement, tir) et la reception des etats du jeu (snapshots, missiles, joueurs).\n\n**Dependances** :\n- Utilise par : `GameScene.cpp`, `Boot.cpp`\n- Depend de : `Protocol.hpp`, `Logger.hpp`, Boost.ASIO\n\n> **Note** : Fichier reseau critique. Toute erreur dans ce composant peut causer des deconnexions ou des desynchronisations.",
      "why": "## Pourquoi c'est un probleme\n\nSonarQube detecte un bloc compose vide (empty compound statement) qui n'est ni implemente ni commente pour expliquer pourquoi il est vide.\n\n**Regle SonarQube** : [cpp:S108](https://rules.sonarsource.com/cpp/RSPEC-108)\n**Categorie** : Maintainability\n**Severite** : Major\n**Effort estime** : 5min\n\n### Visualisation du probleme\n\n```mermaid\nmindmap\n  root((Bloc vide))\n    Code mort\n      Intention peu claire\n      Logique manquante\n    Maintenance\n      Confusion pour les developpeurs\n      Risque de suppression accidentelle\n    Qualite\n      Dette technique\n      Code smell\n```\n\n### Impact dans le projet\n\nCe fichier `UDPClient.cpp` est le composant reseau principal du client. Un bloc vide non documente peut:\n- Masquer une fonctionnalite non implementee\n- Creer de la confusion lors de la maintenance\n- Indiquer un oubli de gestion d'erreur\n\n### Risques\n\n| Risque | Probabilite | Impact |\n|--------|-------------|--------|\n| Code incomplet | Moyenne | Majeur |\n| Confusion maintenance | Haute | Moyen |\n| Comportement indefini | Faible | Critique |",
      "how": "## Comment corriger\n\n### Solution 1 : Implementer le code manquant\n\nSi le bloc devait contenir de la logique:\n\n```cpp\n// Exemple: ajouter un log ou une action\nif (someCondition) {\n    client::logging::Logger::getNetworkLogger()->debug(\"Condition met, handling...\");\n    // Implementer la logique\n}\n```\n\n### Solution 2 : Ajouter un commentaire explicatif\n\nSi le bloc vide est intentionnel:\n\n```cpp\nif (someCondition) {\n    // Intentionally empty: condition is checked but no action needed\n    // because the parent handles the case\n}\n```\n\n### Solution 3 : Supprimer le bloc inutile\n\nSi le bloc n'a aucune utilite, le supprimer entierement.\n\n### Processus de correction\n\n```mermaid\ngraph LR\n    A[Identifier le bloc] --> B{Logique requise?}\n    B -->|Oui| C[Implementer]\n    B -->|Non| D{Intentionnel?}\n    D -->|Oui| E[Commenter]\n    D -->|Non| F[Supprimer]\n    C --> G[Tester]\n    E --> G\n    F --> G\n    style G fill:#6f6,stroke:#333\n```\n\n### Ressources\n\n- [Documentation SonarQube cpp:S108](https://rules.sonarsource.com/cpp/RSPEC-108)"
    },
    {
      "id": "SONAR-002",
      "source": ["sonarqube"],
      "title": "Do not throw uncaught exceptions in a destructor",
      "severity": "Critical",
      "category": "Reliability",
      "status": "pending",
      "isBug": true,
      "file": "src/client/src/network/UDPClient.cpp",
      "line": 28,
      "rule": "cpp:S1048",
      "effort": "30min",
      "agentdb_context": {
        "module": "client/network",
        "is_critical": true,
        "patterns_violated": [],
        "adr_applicable": null,
        "status": "NOT_INDEXED"
      },
      "where": "## Localisation\n\nLe probleme se trouve dans `src/client/src/network/UDPClient.cpp` a la ligne 28.\n\n```cpp\n// Lignes 26-29 - Destructeur UDPClient\nUDPClient::~UDPClient()\n{\n    disconnect();  // PROBLEME: peut lever une exception\n}\n```\n\n### Contexte du fichier\n\n**Module** : client/network\n**Role** : Client UDP gerant la connexion reseau avec le serveur de jeu.\n\n**Methode disconnect() appelee (lignes 121-163)** :\n```cpp\nvoid UDPClient::disconnect()\n{\n    std::scoped_lock lock(_mutex);  // Peut lever std::system_error\n    if (!_connected) {\n        return;\n    }\n    // ... operations sur socket et IO context\n    _ioContext.stop();              // Peut lever des exceptions\n    boost::system::error_code ec;\n    if (_socket.is_open()) {\n        _socket.close(ec);          // Utilise error_code (safe)\n    }\n    // ... nettoyage des collections\n}\n```\n\n**Dependances** :\n- Utilise par : `GameScene.cpp`, `Boot.cpp`\n- Impact : Un crash dans le destructeur peut provoquer `std::terminate()`\n\n> **CRITIQUE** : Le destructeur est marque implicitement `noexcept` en C++11+. Une exception non capturee cause `std::terminate()`.",
      "why": "## Pourquoi c'est un probleme\n\nEn C++11 et versions ulterieures, les destructeurs sont implicitement `noexcept`. Si une exception est levee dans un destructeur et n'est pas capturee, le programme appelle `std::terminate()` et crashe immediatement.\n\n**Regle SonarQube** : [cpp:S1048](https://rules.sonarsource.com/cpp/RSPEC-1048)\n**Categorie** : Reliability\n**Severite** : Critical\n**Effort estime** : 30min\n\n### Visualisation du probleme\n\n```mermaid\nsequenceDiagram\n    participant App as Application\n    participant UDPClient as UDPClient\n    participant Disconnect as disconnect()\n    participant System as std::terminate\n\n    App->>UDPClient: delete client\n    UDPClient->>Disconnect: ~UDPClient() calls disconnect()\n    Disconnect->>Disconnect: std::scoped_lock lock(_mutex)\n    Note over Disconnect: Peut lever std::system_error\n    Disconnect--xUDPClient: Exception non capturee!\n    UDPClient--xSystem: std::terminate()\n    Note over System: CRASH APPLICATION\n```\n\n### Impact dans le projet\n\n| Scenario | Consequence |\n|----------|-------------|\n| Deconnexion normale | Crash si mutex deja verrouille |\n| Fermeture du jeu | Crash aleatoire a la sortie |\n| Stack unwinding | Double exception = terminate |\n| Multi-threading | Race condition sur mutex |\n\n### Risques\n\n| Risque | Probabilite | Impact |\n|--------|-------------|--------|\n| Crash a la fermeture | Haute | Critique |\n| Corruption memoire | Moyenne | Critique |\n| Ressources non liberees | Haute | Majeur |",
      "how": "## Comment corriger\n\n### Solution recommandee : Try-catch dans le destructeur\n\n```cpp\nUDPClient::~UDPClient() noexcept\n{\n    try {\n        disconnect();\n    } catch (const std::exception& e) {\n        // Logger l'erreur mais ne pas propager\n        try {\n            client::logging::Logger::getNetworkLogger()->error(\n                \"Exception in destructor: {}\", e.what());\n        } catch (...) {\n            // Ignorer les erreurs de logging\n        }\n    } catch (...) {\n        // Capturer toute exception inattendue\n    }\n}\n```\n\n### Solution alternative : Methode disconnect() noexcept\n\n```cpp\nvoid UDPClient::disconnectNoexcept() noexcept\n{\n    try {\n        std::unique_lock<std::mutex> lock(_mutex, std::try_to_lock);\n        if (!lock.owns_lock() || !_connected) {\n            return;\n        }\n        _connected = false;\n        _ioContext.stop();\n        \n        boost::system::error_code ec;\n        if (_socket.is_open()) {\n            _socket.close(ec);  // Version noexcept\n        }\n        // Nettoyage sans exception\n    } catch (...) {\n        // Absorber toute exception\n    }\n}\n\nUDPClient::~UDPClient() noexcept\n{\n    disconnectNoexcept();\n}\n```\n\n### Processus de correction\n\n```mermaid\ngraph TD\n    A[Identifier le destructeur] --> B[Envelopper dans try-catch]\n    B --> C[Marquer noexcept explicitement]\n    C --> D[Ajouter logging des erreurs]\n    D --> E[Tester scenarios d'echec]\n    E --> F[Valider avec SonarQube]\n    style F fill:#6f6,stroke:#333\n```\n\n### Ressources\n\n- [Documentation SonarQube cpp:S1048](https://rules.sonarsource.com/cpp/RSPEC-1048)\n- [CppCoreGuidelines C.36](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-dtor-noexcept)"
    },
    {
      "id": "SONAR-003",
      "source": ["sonarqube"],
      "title": "Remove the unused lambda capture \"buf\"",
      "severity": "Minor",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/src/network/UDPClient.cpp",
      "line": 149,
      "rule": "cpp:S1481",
      "effort": "5min",
      "agentdb_context": {
        "module": "client/network",
        "is_critical": true,
        "patterns_violated": [],
        "adr_applicable": null,
        "status": "NOT_INDEXED"
      },
      "where": "## Localisation\n\nLe probleme se trouve dans `src/client/src/network/UDPClient.cpp` a la ligne 149.\n\n```cpp\n// Lignes 145-156 - Bloc de nettoyage dans disconnect()\n{\n    std::lock_guard<std::mutex> plock(_playersMutex);\n    _localPlayerId = std::nullopt;\n    _players.clear();\n    _isLocalPlayerDead = false;\n}\n{\n    std::lock_guard<std::mutex> mlock(_missilesMutex);  // Ligne 149\n    _missiles.clear();\n}\n{\n    std::lock_guard<std::mutex> elock(_enemiesMutex);\n    _enemies.clear();\n}\n```\n\n**Note** : La ligne 149 reference dans SonarQube pointe vers un bloc de nettoyage. Cependant, en analysant le code autour des lambdas avec `buf`, le vrai probleme semble etre ailleurs. Verifions la methode `asyncSendTo` (lignes 220-234) :\n\n```cpp\nvoid UDPClient::asyncSendTo(std::shared_ptr<std::vector<uint8_t>>& buf, size_t totalSize) {\n    if (!isConnected()) {\n        client::logging::Logger::getNetworkLogger()->warn(\"Not connected\");\n        return;\n    }\n    _socket.async_send_to(\n        boost::asio::buffer(buf->data(), totalSize),\n        _endpoint,\n        [buf](const boost::system::error_code &error, std::size_t) {\n            // 'buf' est capture pour maintenir le buffer en vie\n            // mais n'est pas utilise dans le corps de la lambda\n            if (error) {\n                client::logging::Logger::getNetworkLogger()->error(\n                    \"UDP write error: {}\", error.message());\n            }\n        }\n    );\n}\n```\n\n### Contexte du fichier\n\n**Module** : client/network\n**Role** : La capture de `buf` dans la lambda sert a maintenir le `shared_ptr` en vie pendant l'operation asynchrone.\n\n> **Important** : Cette capture est intentionnelle pour eviter une use-after-free, meme si `buf` n'est pas explicitement utilise dans le corps.",
      "why": "## Pourquoi c'est un probleme\n\nSonarQube detecte une capture lambda non utilisee. Cependant, dans ce cas precis, la capture de `buf` (un `shared_ptr`) est **intentionnelle** pour prolonger la duree de vie du buffer pendant l'operation asynchrone.\n\n**Regle SonarQube** : [cpp:S1481](https://rules.sonarsource.com/cpp/RSPEC-1481)\n**Categorie** : Maintainability\n**Severite** : Minor\n**Effort estime** : 5min\n\n### Visualisation du probleme\n\n```mermaid\nsequenceDiagram\n    participant Caller as Appelant\n    participant AsyncSend as asyncSendTo()\n    participant Lambda as Lambda callback\n    participant Buffer as shared_ptr<buf>\n\n    Caller->>AsyncSend: asyncSendTo(buf, size)\n    AsyncSend->>Lambda: Capture [buf]\n    AsyncSend-->>Caller: Retour immediat (async)\n    Note over Buffer: buf maintenu en vie par lambda\n    Lambda->>Lambda: Operation complete\n    Lambda->>Buffer: Release (destruction)\n```\n\n### Analyse : Faux positif ou vrai probleme?\n\n| Aspect | Analyse |\n|--------|--------|\n| Capture utilisee? | Non explicitement dans le corps |\n| Capture necessaire? | **OUI** - maintient le buffer en vie |\n| Supprimer la capture? | **DANGEREUX** - causerait use-after-free |\n| Solution? | Ajouter `[[maybe_unused]]` ou commentaire |\n\n### Impact\n\nCe n'est pas un bug fonctionnel mais un avertissement de maintenabilite. Le code est correct, mais l'intention n'est pas documentee.",
      "how": "## Comment corriger\n\n### Solution 1 : Ajouter un commentaire explicatif (Recommande)\n\n```cpp\n_socket.async_send_to(\n    boost::asio::buffer(buf->data(), totalSize),\n    _endpoint,\n    [buf](const boost::system::error_code &error, std::size_t) {\n        // Note: 'buf' is captured intentionally to keep the buffer alive\n        // during the async operation, even though it's not used explicitly.\n        (void)buf;  // Suppress unused warning\n        if (error) {\n            client::logging::Logger::getNetworkLogger()->error(\n                \"UDP write error: {}\", error.message());\n        }\n    }\n);\n```\n\n### Solution 2 : Utiliser [[maybe_unused]] (C++17)\n\n```cpp\n[buf]([[maybe_unused]] const boost::system::error_code &error,\n      [[maybe_unused]] std::size_t bytes) {\n    // buf intentionally captured for lifetime extension\n    if (error) {\n        client::logging::Logger::getNetworkLogger()->error(\n            \"UDP write error: {}\", error.message());\n    }\n}\n```\n\n### Solution 3 : Utilisation explicite du buffer\n\n```cpp\n[buf](const boost::system::error_code &error, std::size_t bytes_sent) {\n    if (error) {\n        client::logging::Logger::getNetworkLogger()->error(\n            \"UDP write error: {} (buffer size: {})\",\n            error.message(), buf->size());\n    }\n}\n```\n\n### Processus de correction\n\n```mermaid\ngraph LR\n    A[Identifier la lambda] --> B{Capture necessaire?}\n    B -->|Oui| C[Ajouter commentaire/void cast]\n    B -->|Non| D[Supprimer capture]\n    C --> E[Valider compilation]\n    D --> E\n    style E fill:#6f6,stroke:#333\n```\n\n### Ressources\n\n- [Documentation SonarQube cpp:S1481](https://rules.sonarsource.com/cpp/RSPEC-1481)\n- [Boost.ASIO Buffer Lifetime](https://www.boost.org/doc/libs/release/doc/html/boost_asio/overview/core/buffers.html)"
    },
    {
      "id": "SONAR-004",
      "source": ["sonarqube"],
      "title": "Refactor this code to not nest more than 3 if|for|do|while|switch statements",
      "severity": "Critical",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/server/infrastructure/adapters/in/network/UDPServer.cpp",
      "line": 79,
      "rule": "cpp:S134",
      "effort": "10min",
      "agentdb_context": {
        "module": "server/infrastructure/network",
        "is_critical": true,
        "patterns_violated": [],
        "adr_applicable": null,
        "status": "NOT_INDEXED"
      },
      "where": "## Localisation\n\nLe probleme se trouve dans `src/server/infrastructure/adapters/in/network/UDPServer.cpp` a la ligne 79.\n\n```cpp\n// Lignes 76-96 - Methode sendPlayerLeave avec imbrication\nvoid UDPServer::sendPlayerLeave(uint8_t playerId) {\n    const size_t totalSize = UDPHeader::WIRE_SIZE + PlayerLeave::WIRE_SIZE;\n    std::vector<uint8_t> buf(totalSize);\n\n    UDPHeader head{                               // Niveau 1\n        .type = static_cast<uint16_t>(MessageType::PlayerLeave),\n        .sequence_num = 0,\n        .timestamp = UDPHeader::getTimestamp()\n    };\n    head.to_bytes(buf.data());\n\n    PlayerLeave pl{.player_id = playerId};\n    pl.to_bytes(buf.data() + UDPHeader::WIRE_SIZE);\n\n    auto endpoints = _gameWorld.getAllEndpoints();\n    for (const auto& ep : endpoints) {            // Niveau 2 - Boucle\n        sendTo(ep, buf.data(), buf.size());\n    }\n\n    std::cout << \"Player \" << static_cast<int>(playerId) << \" left\" << std::endl;\n}\n```\n\n**Note** : La ligne 79 fait reference a la boucle `for` ou la structure de controle imbriquee. En analysant le fichier, le vrai probleme d'imbrication se trouve dans `handle_receive` (lignes 295-352) :\n\n```cpp\nvoid UDPServer::handle_receive(const boost::system::error_code& error, std::size_t bytes) {\n    if (error) {                                  // Niveau 1\n        // ...\n    }\n    if (bytes < UDPHeader::WIRE_SIZE) {          // Niveau 1\n        // ...\n    }\n    // ...\n    if (!playerIdOpt) {                          // Niveau 1\n        auto newIdOpt = _gameWorld.addPlayer(_remote_endpoint);\n        if (newIdOpt) {                          // Niveau 2\n            // ...\n        } else {                                  // Niveau 2\n            // ...\n        }\n    }\n    // ...\n    if (head.type == static_cast<uint16_t>(MessageType::MovePlayer)) {  // Niveau 1\n        if (payload_size >= MovePlayer::WIRE_SIZE) {                     // Niveau 2\n            auto moveOpt = MovePlayer::from_bytes(payload, payload_size);\n            if (moveOpt) {                                               // Niveau 3\n                _gameWorld.movePlayer(playerId, moveOpt->x, moveOpt->y);\n            }\n        }\n    } else if (...) {                            // Niveau 2 (imbrication)\n        // ...\n    }\n}\n```\n\n### Contexte du fichier\n\n**Module** : server/infrastructure/network\n**Role** : Serveur UDP principal gerant les connexions des joueurs et la diffusion de l'etat du jeu.\n\n**Dependances** :\n- Utilise par : `main.cpp` (serveur)\n- Impact : Fichier critique pour toute la communication reseau du serveur\n\n> **Note** : Fichier critique du serveur. La complexite cyclomatique elevee augmente le risque de bugs.",
      "why": "## Pourquoi c'est un probleme\n\nL'imbrication excessive de structures de controle (if/for/while/switch) rend le code difficile a lire, tester et maintenir. La regle recommande un maximum de 3 niveaux d'imbrication.\n\n**Regle SonarQube** : [cpp:S134](https://rules.sonarsource.com/cpp/RSPEC-134)\n**Categorie** : Maintainability\n**Severite** : Critical\n**Effort estime** : 10min\n\n### Visualisation du probleme\n\n```mermaid\nmindmap\n  root((Imbrication >3))\n    Lisibilite\n      Code difficile a suivre\n      Logique complexe\n    Tests\n      Nombreux chemins d'execution\n      Couverture difficile\n    Maintenance\n      Bugs lors de modifications\n      Refactoring risque\n    Complexite\n      Cyclomatique elevee\n      Cognitive elevee\n```\n\n### Impact dans le projet\n\n| Metrique | Avant | Objectif |\n|----------|-------|----------|\n| Niveaux d'imbrication | 4+ | 3 max |\n| Chemins d'execution | ~16+ | <8 |\n| Complexite cognitive | Elevee | Moyenne |\n\n### Risques\n\n| Risque | Probabilite | Impact |\n|--------|-------------|--------|\n| Bugs lors de modifications | Haute | Majeur |\n| Tests incomplets | Haute | Majeur |\n| Temps de comprehension | Haute | Moyen |",
      "how": "## Comment corriger\n\n### Solution 1 : Early return pattern\n\n```cpp\nvoid UDPServer::handle_receive(const boost::system::error_code& error, std::size_t bytes) {\n    if (error) {\n        std::cerr << \"Receive error: \" << error.message() << std::endl;\n        do_read();\n        return;  // Early return\n    }\n\n    if (bytes < UDPHeader::WIRE_SIZE) {\n        do_read();\n        return;  // Early return\n    }\n\n    auto headOpt = UDPHeader::from_bytes(_readBuffer, bytes);\n    if (!headOpt) {\n        do_read();\n        return;  // Early return\n    }\n\n    // Logique principale avec moins d'imbrication\n    processMessage(*headOpt, bytes);\n    do_read();\n}\n```\n\n### Solution 2 : Extraire en methodes\n\n```cpp\nvoid UDPServer::handle_receive(const boost::system::error_code& error, std::size_t bytes) {\n    if (!validateReceive(error, bytes)) {\n        do_read();\n        return;\n    }\n\n    auto headOpt = UDPHeader::from_bytes(_readBuffer, bytes);\n    if (!headOpt) {\n        do_read();\n        return;\n    }\n\n    uint8_t playerId = ensurePlayerRegistered();\n    if (playerId == 0) {\n        do_read();\n        return;\n    }\n\n    handleMessage(*headOpt, playerId, bytes);\n    do_read();\n}\n\nvoid UDPServer::handleMessage(const UDPHeader& head, uint8_t playerId, size_t bytes) {\n    const uint8_t* payload = _readBuffer + UDPHeader::WIRE_SIZE;\n    size_t payload_size = bytes - UDPHeader::WIRE_SIZE;\n\n    switch (static_cast<MessageType>(head.type)) {\n        case MessageType::MovePlayer:\n            handleMovePlayer(playerId, payload, payload_size);\n            break;\n        case MessageType::ShootMissile:\n            handleShootMissile(playerId);\n            break;\n        default:\n            break;\n    }\n}\n```\n\n### Processus de correction\n\n```mermaid\ngraph LR\n    A[Identifier imbrications] --> B[Appliquer early returns]\n    B --> C[Extraire sous-fonctions]\n    C --> D[Refactorer switch/case]\n    D --> E[Tester tous les chemins]\n    E --> F[Valider complexite < 3]\n    style F fill:#6f6,stroke:#333\n```\n\n### Ressources\n\n- [Documentation SonarQube cpp:S134](https://rules.sonarsource.com/cpp/RSPEC-134)\n- [Guard Clause Pattern](https://refactoring.guru/replace-nested-conditional-with-guard-clauses)"
    },
    {
      "id": "SONAR-005",
      "source": ["sonarqube"],
      "title": "Merge this \"if\" statement with the enclosing one",
      "severity": "Major",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/server/infrastructure/adapters/in/network/UDPServer.cpp",
      "line": 79,
      "rule": "cpp:S1066",
      "effort": "5min",
      "agentdb_context": {
        "module": "server/infrastructure/network",
        "is_critical": true,
        "patterns_violated": [],
        "adr_applicable": null,
        "status": "NOT_INDEXED"
      },
      "where": "## Localisation\n\nLe probleme se trouve dans `src/server/infrastructure/adapters/in/network/UDPServer.cpp` a la ligne 79.\n\nEn analysant le code, les `if` imbriques qui peuvent etre fusionnes se trouvent dans `handle_receive` :\n\n```cpp\n// Lignes 337-349 - If imbriques pouvant etre fusionnes\nif (head.type == static_cast<uint16_t>(MessageType::MovePlayer)) {\n    if (payload_size >= MovePlayer::WIRE_SIZE) {  // PEUT ETRE FUSIONNE\n        auto moveOpt = MovePlayer::from_bytes(payload, payload_size);\n        if (moveOpt) {                            // PEUT ETRE FUSIONNE\n            _gameWorld.movePlayer(playerId, moveOpt->x, moveOpt->y);\n        }\n    }\n} else if (head.type == static_cast<uint16_t>(MessageType::ShootMissile)) {\n    uint16_t missileId = _gameWorld.spawnMissile(playerId);\n    if (missileId > 0) {\n        broadcastMissileSpawned(missileId, playerId);\n    }\n}\n```\n\n### Contexte du fichier\n\n**Module** : server/infrastructure/network\n**Role** : Serveur UDP gerant la reception des messages et la diffusion de l'etat.\n\n**Probleme specifique** : Les deux conditions :\n1. `head.type == MessageType::MovePlayer`\n2. `payload_size >= MovePlayer::WIRE_SIZE`\n\nPeuvent etre combinees avec `&&` pour reduire l'imbrication.\n\n> **Relation avec SONAR-004** : Cette issue est liee a la precedente. Fusionner les `if` reduira aussi l'imbrication.",
      "why": "## Pourquoi c'est un probleme\n\nDes instructions `if` imbriquees sans `else` entre elles peuvent souvent etre fusionnees en une seule condition avec `&&`. Cela ameliore la lisibilite et reduit la profondeur d'imbrication.\n\n**Regle SonarQube** : [cpp:S1066](https://rules.sonarsource.com/cpp/RSPEC-1066)\n**Categorie** : Maintainability\n**Severite** : Major\n**Effort estime** : 5min\n\n### Visualisation du probleme\n\n```mermaid\ngraph TD\n    subgraph Avant\n        A1[if condition1] --> B1[if condition2]\n        B1 --> C1[action]\n    end\n\n    subgraph Apres\n        A2[if condition1 && condition2] --> C2[action]\n    end\n\n    style C1 fill:#f96,stroke:#333\n    style C2 fill:#6f6,stroke:#333\n```\n\n### Code problematique vs code ameliore\n\n| Avant (imbrique) | Apres (fusionne) |\n|------------------|------------------|\n| 3 niveaux | 1-2 niveaux |\n| 6 lignes | 3 lignes |\n| Lisibilite moyenne | Lisibilite bonne |\n\n### Risques\n\n| Risque | Probabilite | Impact |\n|--------|-------------|--------|\n| Dette technique | Moyenne | Faible |\n| Difficulte de lecture | Moyenne | Moyen |\n| Maintenance plus longue | Moyenne | Faible |",
      "how": "## Comment corriger\n\n### Solution : Fusionner les conditions avec &&\n\n**Avant** :\n```cpp\nif (head.type == static_cast<uint16_t>(MessageType::MovePlayer)) {\n    if (payload_size >= MovePlayer::WIRE_SIZE) {\n        auto moveOpt = MovePlayer::from_bytes(payload, payload_size);\n        if (moveOpt) {\n            _gameWorld.movePlayer(playerId, moveOpt->x, moveOpt->y);\n        }\n    }\n}\n```\n\n**Apres** :\n```cpp\nif (head.type == static_cast<uint16_t>(MessageType::MovePlayer)\n    && payload_size >= MovePlayer::WIRE_SIZE) {\n    \n    auto moveOpt = MovePlayer::from_bytes(payload, payload_size);\n    if (moveOpt) {\n        _gameWorld.movePlayer(playerId, moveOpt->x, moveOpt->y);\n    }\n}\n```\n\n### Solution avancee : Extraction en methode\n\n```cpp\nvoid UDPServer::handleMovePlayer(uint8_t playerId, const uint8_t* payload, size_t size) {\n    if (size < MovePlayer::WIRE_SIZE) {\n        return;  // Guard clause\n    }\n    \n    auto moveOpt = MovePlayer::from_bytes(payload, size);\n    if (!moveOpt) {\n        return;  // Guard clause\n    }\n    \n    _gameWorld.movePlayer(playerId, moveOpt->x, moveOpt->y);\n}\n\n// Dans handle_receive:\nif (head.type == static_cast<uint16_t>(MessageType::MovePlayer)) {\n    handleMovePlayer(playerId, payload, payload_size);\n}\n```\n\n### Processus de correction\n\n```mermaid\ngraph LR\n    A[Identifier if imbriques] --> B{Else entre eux?}\n    B -->|Non| C[Fusionner avec &&]\n    B -->|Oui| D[Garder separes]\n    C --> E[Tester]\n    D --> E\n    E --> F[Valider]\n    style F fill:#6f6,stroke:#333\n```\n\n### Ressources\n\n- [Documentation SonarQube cpp:S1066](https://rules.sonarsource.com/cpp/RSPEC-1066)"
    }
  ]
}
