{
  "meta_synthesis": {
    "timestamp": "2025-12-18T14:45:00Z",
    "sources": {
      "synthesis": true,
      "sonar": true
    },
    "stats": {
      "total_issues_before_merge": 45,
      "from_agents": 21,
      "from_sonarqube": 24,
      "internal_duplicates_merged": 4,
      "cross_source_duplicates": 0,
      "final_count": 41
    }
  },
  "synthesis_data": {
    "verdict": "CAREFUL",
    "global_score": 64,
    "scores": {
      "security": 75,
      "reviewer": 78,
      "risk": 52,
      "analyzer": 55
    },
    "merge_ready": false,
    "blocking_issues": 0
  },
  "issues": [
    {
      "id": "RISK-001",
      "source": ["risk"],
      "title": "Large changeset sans tests",
      "severity": "Critical",
      "category": "Reliability",
      "status": "pending",
      "isBug": false,
      "file": "multiple",
      "line": 0,
      "blocking": false,
      "time_estimate_min": 480,
      "where": "## Localisation du probleme\n\nLe probleme concerne l'ensemble du changeset : 20 fichiers C/C++ modifies, +2743 lignes ajoutees.\n\n```\nFichiers principaux sans tests:\n- src/server/infrastructure/game/GameWorld.cpp (+427 lignes)\n- src/client/src/scenes/GameScene.cpp (+360 lignes)\n- src/common/protocol/Protocol.hpp (+322 lignes)\n- src/client/src/accessibility/AccessibilityConfig.cpp (+323 lignes)\n- src/client/src/audio/AudioManager.cpp (+250 lignes)\n```\n\n### Contexte\n\nCe changeset majeur introduit plusieurs nouvelles fonctionnalites (ennemis, audio, accessibilite) sans aucun test unitaire associe.\n\n> Source : risk",
      "why": "## Pourquoi c'est un probleme\n\nUn changeset de cette taille sans tests associes presente un risque eleve de regressions non detectees.\n\n```mermaid\nmindmap\n  root((+2743 lignes))\n    Sans tests\n      Regressions cachees\n      Maintenance difficile\n      Refactoring risque\n    Impact\n      GameWorld - Serveur\n      GameScene - Client\n      Protocol - Reseau\n```\n\n### Impact\n\n- Les bugs potentiels ne seront pas detectes avant la production\n- Maintenance future compliquee sans filet de securite\n- Refactoring impossible sans risque\n\n**Categorie** : Reliability\n**Severite** : Critical",
      "how": "## Comment corriger\n\n### Solution recommandee\n\nAjouter des tests unitaires pour les fichiers critiques.\n\n```bash\n# Tests prioritaires a creer:\ntests/GameWorldTest.cpp     # ~3h\ntests/ProtocolTest.cpp      # ~2h  \ntests/GameSceneTest.cpp     # ~2h\ntests/AccessibilityConfigTest.cpp  # ~1h\n```\n\n### Exemple de test GameWorld\n\n```cpp\nTEST(GameWorld, AddPlayerReturnsValidId) {\n    GameWorld world;\n    auto id = world.addPlayer(mock_endpoint);\n    ASSERT_TRUE(id.has_value());\n    EXPECT_GE(*id, 1);\n    EXPECT_LE(*id, MAX_PLAYERS);\n}\n```\n\n### Validation\n\n- [ ] GameWorldTest.cpp couvre updateWaveSpawning, checkCollisions\n- [ ] ProtocolTest.cpp couvre from_bytes/to_bytes\n- [ ] Tests de non-regression pour le protocole\n\n### Temps estime\n\n480 minutes (~8h)"
    },
    {
      "id": "RISK-002",
      "source": ["risk"],
      "title": "Fichiers critiques sans couverture",
      "severity": "Critical",
      "category": "Reliability",
      "status": "pending",
      "isBug": false,
      "file": "src/common/protocol/Protocol.hpp",
      "line": 1,
      "blocking": false,
      "time_estimate_min": 180,
      "where": "## Localisation du probleme\n\nLe probleme se trouve dans plusieurs fichiers critiques du projet.\n\n```cpp\n// Protocol.hpp - Nouvelles structures sans tests\nstruct EnemyState { ... };        // 8 bytes wire size\nstruct EnemyDestroyed { ... };    // 2 bytes wire size  \nstruct PlayerDamaged { ... };     // 3 bytes wire size\nstruct PlayerDied { ... };        // 1 byte wire size\nstruct GameSnapshot { ... };      // Etendu avec enemies\n\n// GameWorld.cpp - Nouvelles fonctions sans tests\nvoid updateWaveSpawning(float deltaTime);\nvoid updateEnemies(float deltaTime);\nvoid checkCollisions();\n```\n\n### Contexte\n\nCes fichiers sont au coeur de la communication serveur/client et de la logique de jeu.\n\n> Source : risk",
      "why": "## Pourquoi c'est un probleme\n\n```mermaid\ngraph TD\n    A[Protocol.hpp MODIFIE] --> B[Server broadcasts]\n    A --> C[Client parses]\n    B --> D{Serialisation OK?}\n    C --> E{Deserialisation OK?}\n    D -->|Non teste| F[BUG RESEAU]\n    E -->|Non teste| F\n    style F fill:#f66\n```\n\nCes fichiers sont au coeur de la communication serveur/client. Une erreur de serialisation non detectee peut causer des bugs reseau subtils.\n\n**Categorie** : Reliability\n**Severite** : Critical",
      "how": "## Comment corriger\n\n### Tests Protocol.hpp\n\n```cpp\n// ProtocolTest.cpp\nTEST(Protocol, EnemyStateRoundTrip) {\n    EnemyState es{1, 100, 200, 50, 2};\n    uint8_t buf[8];\n    es.to_bytes(buf);\n    auto parsed = EnemyState::from_bytes(buf, 8);\n    ASSERT_TRUE(parsed.has_value());\n    EXPECT_EQ(parsed->id, 1);\n}\n\nTEST(Protocol, GameSnapshotWithEnemies) {\n    GameSnapshot gs;\n    gs.enemy_count = 2;\n    // Test serialization/deserialization\n}\n```\n\n### Tests GameWorld.cpp\n\n```cpp\nTEST(GameWorld, UpdateWaveSpawningIncrementsTimer) {\n    GameWorld world;\n    world.addPlayer(mock_endpoint);\n    world.updateWaveSpawning(0.1f);\n    // Verify wave timer incremented\n}\n```\n\n### Temps estime\n\n180 minutes (~3h)"
    },
    {
      "id": "SEC-001",
      "source": ["security", "risk"],
      "title": "std::stof() sans exception handling (CWE-755)",
      "severity": "Major",
      "category": "Reliability",
      "status": "pending",
      "isBug": true,
      "file": "src/client/src/accessibility/AccessibilityConfig.cpp",
      "line": 265,
      "blocking": false,
      "time_estimate_min": 5,
      "cwe": "CWE-755",
      "where": "## Localisation de la vulnerabilite\n\nLe probleme se trouve dans `src/client/src/accessibility/AccessibilityConfig.cpp` a la ligne 265, dans la fonction `loadFromFile()`.\n\n```cpp\nbool AccessibilityConfig::loadFromFile(const std::string& filepath)\n{\n    std::ifstream file(filepath);\n    // ...\n    if (key == \"game_speed\") {\n        setGameSpeedMultiplier(std::stof(value));  // DANGER: No exception handling\n    }\n}\n```\n\nCette fonction lit un fichier de configuration utilisateur et tente de convertir une chaine en float avec `std::stof()` sans gerer les exceptions.\n\n**Ce probleme provoque un crash de l'application.**\n\n> Source : security, risk (fusionne avec RISK-004)",
      "why": "## Pourquoi c'est un probleme\n\nL'appel a `std::stof()` peut lancer `std::invalid_argument` ou `std::out_of_range`. Si le fichier de configuration contient une valeur invalide, l'application crashera.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Config\n    participant StdLib as std::stof\n    User->>Config: loadFromFile(\"config.txt\")\n    Config->>StdLib: std::stof(\"invalid\")\n    StdLib-->>Config: throw std::invalid_argument\n    Config-->>User: CRASH\n```\n\n| Risque | Probabilite | Impact |\n|--------|-------------|--------|\n| Crash | Moyenne | Majeur |\n\n**Categorie** : Reliability\n**Severite** : Major\n**isBug** : Oui (crash potentiel)",
      "how": "## Comment corriger\n\n### Solution recommandee\n\n```cpp\n} else if (key == \"game_speed\") {\n    try {\n        float speed = std::stof(value);\n        setGameSpeedMultiplier(speed);\n    } catch (const std::invalid_argument& e) {\n        std::cerr << \"Invalid game_speed value: \" << value << std::endl;\n        // Use default value\n    } catch (const std::out_of_range& e) {\n        std::cerr << \"game_speed out of range: \" << value << std::endl;\n        // Use default value\n    }\n}\n```\n\n### Alternative avec std::from_chars (C++17)\n\n```cpp\nfloat speed;\nauto [ptr, ec] = std::from_chars(value.data(), value.data() + value.size(), speed);\nif (ec == std::errc()) {\n    setGameSpeedMultiplier(speed);\n}\n```\n\n### Temps estime\n\n5 minutes"
    },
    {
      "id": "ANA-001",
      "source": ["analyzer"],
      "title": "Protocol Format Change - Backward Incompatible",
      "severity": "Major",
      "category": "Reliability",
      "status": "pending",
      "isBug": false,
      "file": "src/common/protocol/Protocol.hpp",
      "line": 395,
      "blocking": false,
      "time_estimate_min": 15,
      "where": "## Localisation du probleme\n\nLe probleme se trouve dans `src/common/protocol/Protocol.hpp` aux lignes 395-534.\n\n```cpp\nstruct GameSnapshot {\n    uint8_t player_count;\n    PlayerState players[MAX_PLAYERS];\n    uint8_t missile_count;\n    MissileState missiles[MAX_MISSILES];\n    // NEW FIELDS ADDED - BREAKING CHANGE\n    uint8_t enemy_count;                         // +1 byte\n    EnemyState enemies[MAX_ENEMIES];             // +128 bytes max\n    uint8_t enemy_missile_count;                 // +1 byte\n    MissileState enemy_missiles[MAX_ENEMY_MISSILES]; // +224 bytes max\n};\n```\n\nLe format du GameSnapshot a ete etendu pour inclure les ennemis et leurs missiles.\n\n> Source : analyzer",
      "why": "## Pourquoi c'est un probleme\n\nLe protocole binaire UDP est modifie de maniere non retrocompatible.\n\n```mermaid\ngraph TD\n    A[Protocol.hpp - GameSnapshot MODIFIED] --> B[Server broadcasts new format]\n    B --> C[New clients - OK]\n    B --> D[Old clients - PARSE FAILURE]\n    style A fill:#f90\n    style D fill:#f66\n```\n\n### Consequences\n\n- Les clients et serveurs doivent etre mis a jour simultanement\n- Pas de compatibilite ascendante/descendante\n- Deploiement atomique requis\n\n**Categorie** : Reliability\n**Severite** : Major",
      "how": "## Comment corriger\n\n### Option 1: Versionner le protocole\n\n```cpp\nstruct UDPHeader {\n    uint16_t type;\n    uint16_t sequence_num;\n    uint8_t protocol_version;  // ADD VERSION FIELD\n    uint64_t timestamp;\n};\n\n// Server can then handle multiple versions\nswitch (header.protocol_version) {\n    case 1: parseV1Snapshot(buf); break;\n    case 2: parseV2Snapshot(buf); break;\n}\n```\n\n### Option 2: Documenter la rupture dans CHANGELOG\n\n```markdown\n## Breaking Changes v2.0\n\n- GameSnapshot format extended with enemies\n- Requires simultaneous client/server update\n```\n\n### Temps estime\n\n15 minutes"
    },
    {
      "id": "ANA-002",
      "source": ["analyzer"],
      "title": "Interface IWindow Extended",
      "severity": "Major",
      "category": "Reliability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/include/graphics/IWindow.hpp",
      "line": 34,
      "blocking": false,
      "time_estimate_min": 0,
      "where": "## Localisation du probleme\n\nLe probleme se trouve dans `src/client/include/graphics/IWindow.hpp` aux lignes 34-35.\n\n```cpp\nclass IWindow {\n    // Existing methods...\n    \n    // NEW PURE VIRTUAL METHODS\n    virtual bool loadFont(const std::string& key, const std::string& filepath) = 0;\n    virtual void drawText(const std::string& fontKey, const std::string& text,\n                          float x, float y, unsigned int size, rgba color) = 0;\n};\n```\n\n> Source : analyzer",
      "why": "## Pourquoi c'est un probleme\n\nL'ajout de methodes virtuelles pures a une interface casse la compilation si un backend n'implemente pas ces methodes.\n\n```mermaid\ngraph TD\n    A[IWindow.hpp - loadFont/drawText ADDED] --> B[SFMLWindow - IMPLEMENTED]\n    A --> C[SDL2Window - IMPLEMENTED]\n    A --> D[Future backends - MUST IMPLEMENT]\n    style A fill:#f90\n    style D fill:#ff0\n```\n\n### Consequence\n\nTout nouveau backend graphique devra implementer ces methodes.\n\n**Categorie** : Reliability\n**Severite** : Major",
      "how": "## Comment corriger\n\n### Verification\n\nLes implementations sont deja presentes dans les deux backends (SFML, SDL2). Aucune action corrective necessaire.\n\n```cpp\n// SFMLWindow.cpp - OK\nbool SFMLWindow::loadFont(const std::string& key, const std::string& filepath) {\n    // Implemented\n}\n\n// SDL2Window.cpp - OK\nbool SDL2Window::loadFont(const std::string& key, const std::string& filepath) {\n    // Implemented\n}\n```\n\n### Pour les futurs backends\n\nDocumenter l'interface dans le header avec des commentaires explicatifs.\n\n### Temps estime\n\n0 minutes (deja implemente)"
    },
    {
      "id": "REV-001",
      "source": ["reviewer", "risk"],
      "title": "Use of deprecated std::rand()",
      "severity": "Major",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/server/infrastructure/game/GameWorld.cpp",
      "line": 17,
      "blocking": false,
      "time_estimate_min": 30,
      "where": "## Localisation du probleme\n\nLe probleme se trouve dans `src/server/infrastructure/game/GameWorld.cpp` aux lignes 17, 250, 252, 255, 272, 274-275, 285-286, 290, 294.\n\n```cpp\n// Line 17-18 - Constructor\nGameWorld::GameWorld() : _nextPlayerId(1) {\n    std::srand(static_cast<unsigned>(std::time(nullptr)));\n}\n\n// Multiple uses throughout the file:\n.phaseOffset = static_cast<float>(std::rand()) / static_cast<float>(RAND_MAX) * 6.28f,\n.shootCooldown = shootInterval * (0.3f + 0.7f * static_cast<float>(std::rand()) / static_cast<float>(RAND_MAX)),\n.zigzagUp = (std::rand() % 2) == 0\nint roll = std::rand() % 100;\n```\n\n> **Pattern viole** : C++23 best practices - std::rand() est obsolete depuis C++11\n\n> Source : reviewer, risk (fusionne avec RISK-005)",
      "why": "## Pourquoi c'est un probleme\n\n`std::rand()` presente plusieurs problemes :\n- Faible qualite statistique de distribution\n- Non thread-safe (etat global partage)\n- Comportement non portable\n\n```mermaid\nmindmap\n  root((std::rand problemes))\n    Qualite\n      Distribution non uniforme\n      Periode courte\n    Thread Safety\n      Etat global partage\n      Race conditions potentielles\n    Portabilite\n      RAND_MAX varie selon plateforme\n```\n\n### Impact\n\n- Patterns previsibles dans la generation d'ennemis\n- Race condition potentielle en multi-thread\n\n**Categorie** : Maintainability\n**Severite** : Major",
      "how": "## Comment corriger\n\nUtiliser `<random>` de C++11+.\n\n### Solution recommandee\n\n```cpp\n#include <random>\n\nclass GameWorld {\nprivate:\n    std::mt19937 _rng;\n    std::uniform_real_distribution<float> _dist01{0.0f, 1.0f};\n    std::uniform_int_distribution<int> _distPercent{0, 99};\n};\n\nGameWorld::GameWorld() \n    : _nextPlayerId(1), _rng(std::random_device{}())\n{}\n\n// Usage\nfloat randomFloat = _dist01(_rng);  // [0, 1)\nint roll = _distPercent(_rng);       // [0, 99]\nbool coinFlip = std::bernoulli_distribution(0.5)(_rng);\n```\n\n### Temps estime\n\n30 minutes"
    },
    {
      "id": "REV-002",
      "source": ["reviewer", "risk"],
      "title": "Complexite excessive updateWaveSpawning",
      "severity": "Major",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/server/infrastructure/game/GameWorld.cpp",
      "line": 219,
      "blocking": false,
      "time_estimate_min": 45,
      "where": "## Localisation du probleme\n\nLe probleme se trouve dans `src/server/infrastructure/game/GameWorld.cpp` lignes 219-313.\n\n```cpp\nvoid GameWorld::updateWaveSpawning(float deltaTime) {\n    std::lock_guard<std::mutex> lock(_mutex);\n    // 94 lignes avec:\n    // - Verification joueurs vides\n    // - Boucle sur spawn queue\n    // - Switch sur types ennemis (5 cas)\n    // - Update wave timer\n    // - Generation nouvelle wave\n    // - Boucle de spawn avec conditions imbriquees\n}\n```\n\n> **Pattern viole** : complexity (94 LOC, ~20 chemins d'execution)\n\n> Source : reviewer, risk (fusionne avec RISK-003)",
      "why": "## Pourquoi c'est un probleme\n\nUne fonction de 94 lignes avec ~20 chemins d'execution est:\n- Difficile a tester exhaustivement\n- Prone aux bugs lors de modifications\n- Difficile a comprendre pour les nouveaux developpeurs\n\n```mermaid\nmindmap\n  root((updateWaveSpawning 94 LOC))\n    Responsabilites multiples\n      Traiter spawn queue\n      Update wave timer\n      Generer nouvelle wave\n      Determiner types ennemis\n    Tests difficiles\n      20+ chemins\n      Combinatoire explosive\n    Maintenance\n      Risque regression\n      Temps comprehension\n```\n\n**Categorie** : Maintainability\n**Severite** : Major",
      "how": "## Comment corriger\n\nExtraire en sous-fonctions avec responsabilite unique.\n\n### Refactoring propose\n\n```cpp\nvoid GameWorld::updateWaveSpawning(float deltaTime) {\n    std::lock_guard<std::mutex> lock(_mutex);\n    if (_players.empty()) { \n        resetWaveState(); \n        return; \n    }\n    processSpawnQueue(deltaTime);\n    updateWaveTimer(deltaTime);\n}\n\nvoid GameWorld::processSpawnQueue(float deltaTime) {\n    while (!_spawnQueue.empty() && _spawnTimer <= 0) {\n        spawnNextEnemy(_spawnQueue.front());\n        _spawnQueue.pop();\n        _spawnTimer = SPAWN_INTERVAL;\n    }\n    _spawnTimer -= deltaTime;\n}\n\nvoid GameWorld::updateWaveTimer(float deltaTime) {\n    _waveTimer += deltaTime;\n    if (_waveTimer >= WAVE_INTERVAL) {\n        generateNewWave();\n        _waveTimer = 0;\n    }\n}\n\nEnemy GameWorld::createEnemyByType(EnemyType type) {\n    switch (type) {\n        case EnemyType::Basic: return createBasicEnemy();\n        case EnemyType::Zigzag: return createZigzagEnemy();\n        // ...\n    }\n}\n```\n\n### Temps estime\n\n45 minutes"
    },
    {
      "id": "SEC-002",
      "source": ["security", "risk"],
      "title": "Path Traversal potentiel (CWE-22)",
      "severity": "Medium",
      "category": "Security",
      "status": "pending",
      "isBug": false,
      "file": "src/client/src/accessibility/AccessibilityConfig.cpp",
      "line": 240,
      "blocking": false,
      "time_estimate_min": 15,
      "cwe": "CWE-22",
      "where": "## Localisation du probleme\n\nLe probleme se trouve dans `src/client/src/accessibility/AccessibilityConfig.cpp` a la ligne 240.\n\n```cpp\nbool AccessibilityConfig::loadFromFile(const std::string& filepath)\n{\n    std::ifstream file(filepath);  // Aucune validation du chemin\n    if (!file.is_open()) {\n        return false;\n    }\n    // ...\n}\n\nbool AccessibilityConfig::saveToFile(const std::string& filepath)\n{\n    std::ofstream file(filepath);  // Aucune validation du chemin\n    // ...\n}\n```\n\n> Source : security, risk (fusionne avec RISK-006)",
      "why": "## Pourquoi c'est un probleme\n\nAccepte n'importe quel chemin sans validation.\n\n```mermaid\ngraph TD\n    A[User Input] --> B[filepath parameter]\n    B --> C{Validation?}\n    C -->|Non| D[std::ifstream/ofstream]\n    D --> E[File Access]\n    E --> F[Potential path traversal]\n    style F fill:#f90\n```\n\n### Risque\n\n- Risque faible pour client local (l'utilisateur controle deja sa machine)\n- Pourrait devenir problematique si filepath vient d'une source externe\n\n**Categorie** : Security\n**Severite** : Medium",
      "how": "## Comment corriger\n\n### Solution avec std::filesystem\n\n```cpp\n#include <filesystem>\n\nbool AccessibilityConfig::loadFromFile(const std::string& filepath)\n{\n    namespace fs = std::filesystem;\n    \n    // Normalize and validate path\n    fs::path p = fs::weakly_canonical(filepath);\n    \n    // Check it's within allowed directory\n    fs::path configDir = fs::weakly_canonical(\"config/\");\n    if (!p.string().starts_with(configDir.string())) {\n        return false;  // Path outside allowed directory\n    }\n    \n    std::ifstream file(p);\n    // ...\n}\n```\n\n### Temps estime\n\n15 minutes"
    },
    {
      "id": "REV-003",
      "source": ["reviewer"],
      "title": "Protocol.hpp trop long",
      "severity": "Medium",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/common/protocol/Protocol.hpp",
      "line": 1,
      "blocking": false,
      "time_estimate_min": 30,
      "where": "## Localisation du probleme\n\nLe fichier `src/common/protocol/Protocol.hpp` fait 537 lignes et contient toutes les structures de protocole dans un seul header.\n\n```cpp\n// Protocol.hpp - 537 lignes\n// Contient:\n// - swap16/32/64 functions\n// - enum MessageType\n// - UDPHeader struct\n// - PlayerState struct\n// - MissileState struct\n// - EnemyState struct\n// - GameSnapshot struct\n// - 10+ autres structures\n```\n\n> Source : reviewer",
      "why": "## Pourquoi c'est un probleme\n\nUn header de 537 lignes :\n- Augmente les temps de compilation (inclus partout)\n- Difficile a naviguer\n- Viole le principe de responsabilite unique\n\n```mermaid\nmindmap\n  root((Protocol.hpp 537 LOC))\n    Compilation\n      Inclus partout\n      Rebuild frequent\n    Navigation\n      Difficile a lire\n      Ctrl+F obligatoire\n    Maintenance\n      Responsabilite unique violee\n      Couplage eleve\n```\n\n**Categorie** : Maintainability\n**Severite** : Medium",
      "how": "## Comment corriger\n\nSeparer en plusieurs fichiers par domaine:\n\n```\nsrc/common/protocol/\n  Protocol.hpp          # Include principal (forward declarations)\n  ByteSwap.hpp          # swap16/32/64\n  MessageTypes.hpp      # enum MessageType\n  Header.hpp            # UDPHeader\n  PlayerMessages.hpp    # PlayerState, PlayerJoin, PlayerLeave, etc.\n  MissileMessages.hpp   # MissileState, MissileSpawned, etc.\n  EnemyMessages.hpp     # EnemyState, EnemyDestroyed\n  GameSnapshot.hpp      # struct GameSnapshot\n```\n\n### Temps estime\n\n30 minutes"
    },
    {
      "id": "REV-004",
      "source": ["reviewer"],
      "title": "GameWorld.cpp trop long",
      "severity": "Medium",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/server/infrastructure/game/GameWorld.cpp",
      "line": 1,
      "blocking": false,
      "time_estimate_min": 120,
      "where": "## Localisation du probleme\n\nLe fichier `src/server/infrastructure/game/GameWorld.cpp` fait 549 lignes avec responsabilites multiples.\n\n```cpp\n// GameWorld.cpp - 549 lignes\n// Responsabilites:\n// - Gestion des joueurs (add, remove, update)\n// - Gestion des missiles (spawn, update, destroy)\n// - Gestion des ennemis (spawn, update, AI)\n// - Gestion des waves (timing, generation)\n// - Detection des collisions\n// - Snapshot generation\n```\n\n> Source : reviewer",
      "why": "## Pourquoi c'est un probleme\n\nDepasse le seuil de 500 LOC recommande avec trop de responsabilites.\n\n```mermaid\nmindmap\n  root((GameWorld 549 LOC))\n    Responsabilites\n      Players\n      Missiles\n      Enemies\n      Waves\n      Collisions\n      Snapshots\n    Problemes\n      Difficile a tester\n      Couplage fort\n      God object\n```\n\n**Categorie** : Maintainability\n**Severite** : Medium",
      "how": "## Comment corriger\n\nExtraire en classes specialisees:\n\n```cpp\n// PlayerManager.cpp - Gestion des joueurs\nclass PlayerManager {\n    std::optional<uint8_t> addPlayer(const udp::endpoint& ep);\n    void removePlayer(uint8_t id);\n    void updatePosition(uint8_t id, uint16_t x, uint16_t y);\n};\n\n// MissileManager.cpp - Gestion des missiles\nclass MissileManager {\n    void spawnMissile(uint8_t ownerId, uint16_t x, uint16_t y);\n    void updateMissiles(float deltaTime);\n};\n\n// EnemyManager.cpp - Gestion des ennemis\nclass EnemyManager {\n    void spawnEnemy(EnemyType type);\n    void updateEnemies(float deltaTime);\n};\n\n// CollisionSystem.cpp - Detection des collisions\nclass CollisionSystem {\n    void checkCollisions(PlayerManager&, MissileManager&, EnemyManager&);\n};\n\n// GameWorld.cpp - Orchestration uniquement (~100 LOC)\nclass GameWorld {\n    PlayerManager _players;\n    MissileManager _missiles;\n    EnemyManager _enemies;\n    CollisionSystem _collisions;\n};\n```\n\n### Temps estime\n\n120 minutes (~2h)"
    },
    {
      "id": "REV-005",
      "source": ["reviewer"],
      "title": "Magic numbers dans GameScene",
      "severity": "Medium",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/src/scenes/GameScene.cpp",
      "line": 152,
      "blocking": false,
      "time_estimate_min": 10,
      "where": "## Localisation du probleme\n\nLe probleme se trouve dans `src/client/src/scenes/GameScene.cpp` aux lignes 152-153.\n\n```cpp\n// Lines 152-153\nnewX = std::clamp(newX, 0, 1920 - static_cast<int>(SHIP_WIDTH));\nnewY = std::clamp(newY, 0, 1080 - static_cast<int>(SHIP_HEIGHT));\n```\n\nLes valeurs 1920 et 1080 sont des magic numbers non documentes.\n\n> Source : reviewer",
      "why": "## Pourquoi c'est un probleme\n\nLes magic numbers :\n- Rendent le code difficile a comprendre\n- Peuvent causer des incohÃ©rences si modifies a un seul endroit\n- Ne documentent pas l'intention\n\n```mermaid\nmindmap\n  root((Magic numbers))\n    Problemes\n      Intention floue\n      Duplication risquee\n      Maintenance difficile\n    Valeurs\n      1920 = SCREEN_WIDTH?\n      1080 = SCREEN_HEIGHT?\n```\n\n**Categorie** : Maintainability\n**Severite** : Medium",
      "how": "## Comment corriger\n\n### Utiliser les constantes existantes\n\n```cpp\n// GameScene.hpp - constantes\nstatic constexpr int SCREEN_WIDTH = 1920;\nstatic constexpr int SCREEN_HEIGHT = 1080;\n\n// Ou recuperer dynamiquement\nauto [width, height] = _context.window->getSize();\n\n// Usage\nnewX = std::clamp(newX, 0, SCREEN_WIDTH - static_cast<int>(SHIP_WIDTH));\nnewY = std::clamp(newY, 0, SCREEN_HEIGHT - static_cast<int>(SHIP_HEIGHT));\n```\n\n### Temps estime\n\n10 minutes"
    },
    {
      "id": "SEC-003",
      "source": ["security"],
      "title": "Validation incomplete donnees reseau (CWE-20)",
      "severity": "Minor",
      "category": "Security",
      "status": "pending",
      "isBug": false,
      "file": "src/common/protocol/Protocol.hpp",
      "line": 439,
      "blocking": false,
      "time_estimate_min": 30,
      "cwe": "CWE-20",
      "where": "## Localisation du probleme\n\nLe probleme se trouve dans `src/common/protocol/Protocol.hpp` autour de la ligne 439, dans les fonctions `from_bytes()`.\n\n```cpp\nstatic std::optional<PlayerState> from_bytes(const void* buf, size_t buf_len) {\n    if (buf == nullptr || buf_len < WIRE_SIZE) return std::nullopt;\n    auto* ptr = static_cast<const uint8_t*>(buf);\n    \n    PlayerState ps;\n    // Parsing sans validation semantique\n    ps.x = swap16(net_x);  // Pas de validation: 0 <= x <= MAX_X?\n    ps.y = swap16(net_y);  // Pas de validation: 0 <= y <= MAX_Y?\n    ps.health = ptr[5];    // Pas de validation: health <= 100?\n    return ps;\n}\n```\n\n> Source : security",
      "why": "## Pourquoi c'est un probleme\n\nLes valeurs x, y, health ne sont pas validees semantiquement dans from_bytes().\n\n```mermaid\nsequenceDiagram\n    participant Attacker as Serveur malveillant\n    participant Client\n    participant Renderer\n    Attacker->>Client: PlayerState{x=99999, y=-1, health=255}\n    Client->>Renderer: Draw at (99999, -1)\n    Renderer-->>Client: Comportement indefini\n```\n\n### Risque\n\n- Un serveur malveillant pourrait envoyer des positions hors ecran\n- Risque mineur car serveur de confiance dans l'architecture actuelle\n\n**Categorie** : Security\n**Severite** : Minor",
      "how": "## Comment corriger\n\n### Validation optionnelle\n\n```cpp\nstatic std::optional<PlayerState> from_bytes(const void* buf, size_t buf_len) {\n    // ... parsing ...\n    \n    // Optional semantic validation\n    #ifdef VALIDATE_NETWORK_DATA\n    if (ps.x > MAX_SCREEN_X || ps.y > MAX_SCREEN_Y) {\n        return std::nullopt;\n    }\n    if (ps.health > 100) {\n        ps.health = 100;  // Clamp to valid range\n    }\n    #endif\n    \n    return ps;\n}\n```\n\n### Temps estime\n\n30 minutes"
    },
    {
      "id": "ANA-003",
      "source": ["analyzer"],
      "title": "Nouvelle dependance SDL2_mixer",
      "severity": "Minor",
      "category": "Build",
      "status": "pending",
      "isBug": false,
      "file": "src/client/include/audio/AudioManager.hpp",
      "line": 15,
      "blocking": false,
      "time_estimate_min": 5,
      "where": "## Localisation du probleme\n\nLe probleme se trouve dans `src/client/include/audio/AudioManager.hpp` a la ligne 15.\n\n```cpp\n#include <SDL2/SDL_mixer.h>\n```\n\nNouvelle dependance sur la bibliotheque SDL2_mixer.\n\n> Source : analyzer",
      "why": "## Pourquoi c'est important\n\nSDL2_mixer doit etre ajoute aux dependances du projet pour que le build fonctionne.\n\n```mermaid\ngraph TD\n    A[AudioManager.hpp] --> B[SDL2_mixer.h]\n    B --> C{vcpkg.json?}\n    C -->|Manquant| D[BUILD FAILURE]\n    C -->|Present| E[OK]\n    style D fill:#f66\n```\n\n**Categorie** : Build\n**Severite** : Minor",
      "how": "## Comment corriger\n\n### Verifier vcpkg.json\n\n```json\n{\n  \"dependencies\": [\n    \"sdl2\",\n    \"sdl2-mixer\",  // Verifier presence\n    \"sdl2-image\"\n  ]\n}\n```\n\n### Verifier CMakeLists.txt\n\n```cmake\nfind_package(SDL2_mixer CONFIG REQUIRED)\ntarget_link_libraries(rtype_client PRIVATE SDL2_mixer::SDL2_mixer)\n```\n\n### Temps estime\n\n5 minutes"
    },
    {
      "id": "ANA-004",
      "source": ["analyzer"],
      "title": "Game Loop Complexity Increased",
      "severity": "Minor",
      "category": "Performance",
      "status": "pending",
      "isBug": false,
      "file": "src/server/infrastructure/adapters/in/network/UDPServer.cpp",
      "line": 121,
      "blocking": false,
      "time_estimate_min": 0,
      "where": "## Localisation du probleme\n\nLe probleme se trouve dans `src/server/infrastructure/adapters/in/network/UDPServer.cpp` a la ligne 121.\n\n```cpp\nvoid UDPServer::scheduleBroadcast() {\n    _broadcastTimer.expires_after(std::chrono::milliseconds(50));\n    _broadcastTimer.async_wait([this](const boost::system::error_code& ec) {\n        // ...\n        _gameWorld.updateMissiles(deltaTime);\n        _gameWorld.updateWaveSpawning(deltaTime);   // NEW\n        _gameWorld.updateEnemies(deltaTime);        // NEW\n        _gameWorld.checkCollisions();               // NEW\n        broadcastGameState();\n    });\n}\n```\n\n> Source : analyzer",
      "why": "## Pourquoi c'est important\n\nLa charge CPU par tick a augmente avec les nouvelles fonctions.\n\n```mermaid\ngraph LR\n    A[Tick 50ms] --> B[updateMissiles O-n-]\n    A --> C[updateWaveSpawning O-1-]\n    A --> D[updateEnemies O-m-]\n    A --> E[checkCollisions O-n*m-]\n    style E fill:#f90\n```\n\n### Complexite\n\n- `checkCollisions()` est O(missiles * enemies + enemyMissiles * players)\n- Peut devenir problematique avec beaucoup d'entites\n\n**Categorie** : Performance\n**Severite** : Minor",
      "how": "## Comment corriger\n\n### Optimisations possibles (post-MVP)\n\n1. **Spatial partitioning** : Quadtree ou grid pour reduire les tests de collision\n\n```cpp\nclass SpatialGrid {\n    std::vector<Entity*> grid[GRID_WIDTH][GRID_HEIGHT];\n    std::vector<Entity*> getNearby(float x, float y);\n};\n```\n\n2. **Early exit** : Arreter la boucle des la premiere collision\n\n3. **Profiling** : Mesurer avant d'optimiser\n\n```cpp\nauto start = std::chrono::high_resolution_clock::now();\ncheckCollisions();\nauto duration = std::chrono::high_resolution_clock::now() - start;\n```\n\n### Temps estime\n\n0 minutes (optimisation future)"
    },
    {
      "id": "REV-006",
      "source": ["reviewer"],
      "title": "Methodes draw/drawImg non implementees",
      "severity": "Minor",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sfml/src/SFMLWindow.cpp",
      "line": 113,
      "blocking": false,
      "time_estimate_min": 15,
      "where": "## Localisation du probleme\n\nLe probleme se trouve dans `src/client/lib/sfml/src/SFMLWindow.cpp` aux lignes 113-115 et 124+.\n\n```cpp\n// Lines 113-115 - Empty draw method\nvoid SFMLWindow::draw(const graphics::IDrawable& drawable) {\n    // _window.drawAll();\n}\n\n// Line 124+ - drawImg\nvoid SFMLWindow::drawImg(graphics::IDrawable drawable, float x, float y, float scaleX, float scaleY) {\n    // Empty or minimal implementation\n}\n```\n\n> Source : reviewer",
      "why": "## Pourquoi c'est un probleme\n\nDes methodes d'interface non implementees peuvent causer des comportements inattendus si appelees.\n\n```mermaid\ngraph TD\n    A[Code appelle draw] --> B[SFMLWindow::draw]\n    B --> C{Implementation?}\n    C -->|Vide| D[Rien ne se passe]\n    D --> E[Bug silencieux]\n    style E fill:#f90\n```\n\n**Categorie** : Maintainability\n**Severite** : Minor",
      "how": "## Comment corriger\n\n### Option 1: Implementer les methodes\n\n```cpp\nvoid SFMLWindow::draw(const graphics::IDrawable& drawable) {\n    drawable.draw(*this);\n}\n```\n\n### Option 2: Lever une exception\n\n```cpp\nvoid SFMLWindow::draw(const graphics::IDrawable& drawable) {\n    throw std::runtime_error(\"draw(IDrawable) not implemented - use specific draw methods\");\n}\n```\n\n### Option 3: Documenter l'intention\n\n```cpp\nvoid SFMLWindow::draw(const graphics::IDrawable&) {\n    // Not implemented: SFML backend uses specific methods\n    // (drawRect, drawSprite, drawText) instead of generic IDrawable\n}\n```\n\n### Temps estime\n\n15 minutes"
    },
    {
      "id": "REV-007",
      "source": ["reviewer"],
      "title": "Commentaire debug dans main.cpp",
      "severity": "Minor",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/main.cpp",
      "line": 31,
      "blocking": false,
      "time_estimate_min": 2,
      "where": "## Localisation du probleme\n\nLe probleme se trouve dans `src/client/main.cpp` a la ligne 30-31.\n\n```cpp\ncatch(const std::exception& e)\n{\n    // client::logging::Logger::error(\"Exception caught: {}\", e.what());\n    return EXIT_FAILURE;\n}\n```\n\nLe logging d'erreur est commente, ce qui signifie que les exceptions sont avalees silencieusement.\n\n> Source : reviewer",
      "why": "## Pourquoi c'est un probleme\n\nUn code de logging commente:\n- Rend le debugging plus difficile\n- Masque les erreurs en production\n- Indique du code mort ou en cours de developpement\n\n```mermaid\ngraph TD\n    A[Exception lancee] --> B[catch block]\n    B --> C{Logger actif?}\n    C -->|Commente| D[Erreur silencieuse]\n    C -->|Actif| E[Log visible]\n    style D fill:#f90\n```\n\n**Categorie** : Maintainability\n**Severite** : Minor",
      "how": "## Comment corriger\n\n### Reactiver le logging\n\n```cpp\ncatch(const std::exception& e)\n{\n    client::logging::Logger::error(\"Exception caught: {}\", e.what());\n    return EXIT_FAILURE;\n}\n```\n\n### Ou utiliser std::cerr si Logger non disponible\n\n```cpp\ncatch(const std::exception& e)\n{\n    std::cerr << \"Exception caught: \" << e.what() << std::endl;\n    return EXIT_FAILURE;\n}\n```\n\n### Temps estime\n\n2 minutes"
    },
    {
      "id": "REV-008",
      "source": ["reviewer"],
      "title": "swap64 type de retour incorrect",
      "severity": "Minor",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/common/protocol/Protocol.hpp",
      "line": 16,
      "blocking": false,
      "time_estimate_min": 2,
      "where": "## Localisation du probleme\n\nLe probleme se trouve dans `src/common/protocol/Protocol.hpp` a la ligne 16.\n\n```cpp\n// ERREUR: Type de retour et parametre incorrects\ninline uint32_t swap64(uint32_t v) { return __builtin_bswap64(v); }\n\n// Devrait etre:\ninline uint64_t swap64(uint64_t v) { return __builtin_bswap64(v); }\n```\n\n> Source : reviewer",
      "why": "## Pourquoi c'est un probleme\n\nLa fonction swap64 utilise des types 32-bit au lieu de 64-bit:\n- Troncature des valeurs 64-bit\n- Comportement indefini potentiel\n- Le nom de la fonction est trompeur\n\n```mermaid\ngraph TD\n    A[uint64_t timestamp] --> B[swap64 uint32_t]\n    B --> C[Troncature!]\n    C --> D[Valeur incorrecte]\n    style C fill:#f66\n```\n\n### Impact\n\nCette fonction est utilisee pour les timestamps 64-bit dans UDPHeader. Les 32 bits superieurs sont tronques.\n\n**Categorie** : Maintainability\n**Severite** : Minor (mais potentiellement dangereux)",
      "how": "## Comment corriger\n\n### Correction simple\n\n```cpp\n// AVANT\ninline uint32_t swap64(uint32_t v) { return __builtin_bswap64(v); }\n\n// APRES\ninline uint64_t swap64(uint64_t v) { return __builtin_bswap64(v); }\n```\n\n### Temps estime\n\n2 minutes"
    },
    {
      "id": "SONAR-001",
      "source": ["sonarqube"],
      "title": "Empty catch block should be documented",
      "severity": "Major",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/src/network/UDPClient.cpp",
      "line": 169,
      "rule": "cpp:S108",
      "effort": "5min",
      "where": "## Localisation\n\nLe probleme se trouve dans `src/client/src/network/UDPClient.cpp` a la ligne 169.\n\n```cpp\n// Context in UDPClient.cpp\n// A block with empty body or only comment\nif (condition) {\n    // Empty or commented out\n}\n```\n\n### Contexte du fichier\n\nCe fichier implemente le client reseau UDP pour la communication avec le serveur de jeu.\n\n**Module** : client/network\n**Critique** : Oui (synchronisation multijoueur)",
      "why": "## Pourquoi c'est un probleme\n\nUn bloc compound vide peut indiquer du code incomplet ou oublie.\n\n```mermaid\nmindmap\n  root((Bloc vide))\n    Risques\n      Code incomplet\n      Intention floue\n      Bug potentiel\n    Solutions\n      Ajouter commentaire\n      Implementer logique\n      Supprimer si inutile\n```\n\n**Regle SonarQube** : cpp:S108\n**Effort** : 5min",
      "how": "## Comment corriger\n\nAjouter un commentaire explicatif si intentionnel, ou implementer la logique manquante.\n\n```cpp\nif (condition) {\n    // Intentionally empty: no action needed\n}\n```"
    },
    {
      "id": "SONAR-002",
      "source": ["sonarqube"],
      "title": "Do not throw uncaught exceptions in a destructor",
      "severity": "Critical",
      "category": "Reliability",
      "status": "pending",
      "isBug": true,
      "file": "src/client/src/network/UDPClient.cpp",
      "line": 28,
      "rule": "cpp:S1048",
      "effort": "30min",
      "where": "## Localisation\n\nLe probleme se trouve dans `src/client/src/network/UDPClient.cpp` a la ligne 28.\n\n```cpp\nUDPClient::~UDPClient()\n{\n    disconnect();  // Peut lancer des exceptions\n}\n```\n\n**Ce probleme provoque un crash de l'application.**",
      "why": "## Pourquoi c'est un probleme\n\nLancer une exception dans un destructeur est extremement dangereux en C++.\n\n```mermaid\ngraph TD\n    A[Exception active] --> B[Destructeur appele]\n    B --> C[disconnect lance exception]\n    C --> D[Double exception]\n    D --> E[std::terminate]\n    E --> F[CRASH]\n    style F fill:#f66\n```\n\n**Regle SonarQube** : cpp:S1048\n**Severite** : Critical",
      "how": "## Comment corriger\n\n```cpp\nUDPClient::~UDPClient() noexcept\n{\n    try {\n        disconnect();\n    } catch (const std::exception& e) {\n        // Log but don't propagate\n    } catch (...) {\n        // Catch all\n    }\n}\n```"
    },
    {
      "id": "SONAR-003",
      "source": ["sonarqube"],
      "title": "Remove the unused lambda capture buf",
      "severity": "Minor",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/src/network/UDPClient.cpp",
      "line": 149,
      "rule": "cpp:S1481",
      "effort": "5min",
      "where": "## Localisation\n\nCapture lambda potentiellement inutilisee dans UDPClient.cpp.\n\n```cpp\n[buf](const boost::system::error_code &error, std::size_t) {\n    // buf capture pour le lifetime mais non utilise explicitement\n}\n```\n\n**Note** : Possiblement un faux positif - la capture maintient le shared_ptr en vie.",
      "why": "## Pourquoi c'est signale\n\nSonarQube detecte une capture non utilisee explicitement.\n\n```mermaid\nmindmap\n  root((Capture buf))\n    Faux positif possible\n      Gestion lifetime RAII\n      shared_ptr maintenu\n```\n\n**Regle SonarQube** : cpp:S1481",
      "how": "## Comment gerer\n\n```cpp\n[buf](...) {\n    (void)buf; // Explicitly mark as used for lifetime\n    // ...\n}\n```"
    },
    {
      "id": "SONAR-004",
      "source": ["sonarqube"],
      "title": "Replace void* with a more meaningful type (to_bytes)",
      "severity": "Critical",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/common/protocol/Protocol.hpp",
      "line": 88,
      "rule": "cpp:S5008",
      "effort": "10min",
      "where": "## Localisation\n\n```cpp\nvoid to_bytes(void* buf) const {\n    auto* ptr = static_cast<uint8_t*>(buf);\n    // ...\n}\n```\n\nL'utilisation de void* perd la securite de typage.",
      "why": "## Pourquoi c'est un probleme\n\n```mermaid\ngraph TD\n    A[void* buf] --> B{Type reel?}\n    B -->|uint8_t*| C[OK]\n    B -->|int*| D[BUG SILENCIEUX]\n    style D fill:#f66\n```\n\n**Regle SonarQube** : cpp:S5008\n**Severite** : Critical",
      "how": "## Comment corriger\n\n```cpp\n// APRES\nvoid to_bytes(uint8_t* buf) const {\n    // Plus besoin de cast\n}\n```"
    },
    {
      "id": "SONAR-005",
      "source": ["sonarqube"],
      "title": "Replace void* with a more meaningful type (from_bytes)",
      "severity": "Critical",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/common/protocol/Protocol.hpp",
      "line": 182,
      "rule": "cpp:S5008",
      "effort": "10min",
      "where": "## Localisation\n\n```cpp\nstatic std::optional<MissileState> from_bytes(const void* buf, size_t buf_len) {\n    auto* ptr = static_cast<const uint8_t*>(buf);\n    // ...\n}\n```",
      "why": "## Pourquoi c'est un probleme\n\nMeme raison que SONAR-004.\n\n**Regle SonarQube** : cpp:S5008",
      "how": "## Comment corriger\n\n```cpp\nstatic std::optional<MissileState> from_bytes(const uint8_t* buf, size_t buf_len)\n```"
    },
    {
      "id": "SONAR-006",
      "source": ["sonarqube"],
      "title": "Refactor to not nest more than 3 control statements",
      "severity": "Critical",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/server/infrastructure/adapters/in/network/UDPServer.cpp",
      "line": 79,
      "rule": "cpp:S134",
      "effort": "10min",
      "where": "## Localisation\n\nNiveau d'imbrication > 3 dans UDPServer.cpp.\n\n```cpp\nvoid UDPServer::sendPlayerLeave(uint8_t playerId) {\n    // Multiple levels of nesting\n    for (const auto& ep : endpoints) {\n        // ...\n    }\n}\n```",
      "why": "## Pourquoi c'est un probleme\n\n```mermaid\nmindmap\n  root((Imbrication > 3))\n    Problemes\n      Lisibilite reduite\n      Tests complexes\n    Solutions\n      Early return\n      Extract method\n```\n\n**Regle SonarQube** : cpp:S134",
      "how": "## Comment corriger\n\nUtiliser early return et extract method patterns."
    },
    {
      "id": "SONAR-007",
      "source": ["sonarqube"],
      "title": "Merge this if statement with the enclosing one",
      "severity": "Major",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/server/infrastructure/adapters/in/network/UDPServer.cpp",
      "line": 79,
      "rule": "cpp:S1066",
      "effort": "5min",
      "where": "## Localisation\n\nIf imbriques fusionnables dans UDPServer.cpp.\n\n```cpp\nif (condition1) {\n    if (condition2) {\n        // action\n    }\n}\n```",
      "why": "## Pourquoi c'est un probleme\n\nAugmente inutilement la complexite.\n\n**Regle SonarQube** : cpp:S1066",
      "how": "## Comment corriger\n\n```cpp\nif (condition1 && condition2) {\n    // action\n}\n```"
    },
    {
      "id": "SONAR-008",
      "source": ["sonarqube"],
      "title": "Use init-statement to declare variable inside if",
      "severity": "Minor",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sdl2/src/SDL2Window.cpp",
      "line": 131,
      "rule": "cpp:S6004",
      "effort": "2min",
      "where": "## Localisation\n\n```cpp\nSDL_Event sdlEvent;\nif (SDL_PollEvent(&sdlEvent)) {\n    // use sdlEvent\n}\n```",
      "why": "## Pourquoi c'est suggere\n\nC++17 permet de limiter la portee des variables.\n\n**Regle SonarQube** : cpp:S6004",
      "how": "## Comment corriger\n\n```cpp\nif (SDL_Event sdlEvent; SDL_PollEvent(&sdlEvent)) {\n    // use sdlEvent - scope limited\n}\n```"
    },
    {
      "id": "SONAR-009",
      "source": ["sonarqube"],
      "title": "Customize copy constructor for resource management (Rule of 5)",
      "severity": "Critical",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sdl2/include/SDL2Window.hpp",
      "line": 18,
      "rule": "cpp:S3624",
      "effort": "30min",
      "where": "## Localisation\n\n```cpp\nclass SDL2Window: public graphics::IWindow {\n    public:\n        SDL2Window(Vec2u winSize, const std::string& name);\n        ~SDL2Window();  // Destructeur custom\n        // MANQUANT: copy/move operations\n    private:\n        SDL_Window* _window;       // Ressource\n        SDL_Renderer* _renderer;   // Ressource\n};\n```",
      "why": "## Pourquoi c'est un probleme\n\nRule of Five violation - risque de double-free ou dangling pointers.\n\n```mermaid\ngraph TD\n    A[SDL2Window w1] --> B[SDL_Window*]\n    C[SDL2Window w2 = w1] --> B\n    D[w1 detruit] --> E[DANGLING POINTER]\n    style E fill:#f66\n```\n\n**Regle SonarQube** : cpp:S3624",
      "how": "## Comment corriger\n\n```cpp\n// Disable copy, enable move\nSDL2Window(const SDL2Window&) = delete;\nSDL2Window& operator=(const SDL2Window&) = delete;\nSDL2Window(SDL2Window&& other) noexcept;\nSDL2Window& operator=(SDL2Window&& other) noexcept;\n```"
    },
    {
      "id": "SONAR-010",
      "source": ["sonarqube"],
      "title": "Annotate function with override or final",
      "severity": "Minor",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sdl2/include/SDL2Window.hpp",
      "line": 21,
      "rule": "cpp:S3471",
      "effort": "5min",
      "where": "## Localisation\n\nCertaines methodes virtuelles peuvent manquer l'attribut override.\n\n```cpp\nbool isOpen();  // Devrait avoir override\n```",
      "why": "## Pourquoi c'est important\n\n`override` permet au compilateur de verifier la signature.\n\n**Regle SonarQube** : cpp:S3471",
      "how": "## Comment corriger\n\n```cpp\nbool isOpen() override;\n```"
    },
    {
      "id": "SONAR-011",
      "source": ["sonarqube"],
      "title": "Reduce verbosity with using enum",
      "severity": "Minor",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sdl2/src/SDL2Window.cpp",
      "line": 15,
      "rule": "cpp:S6004",
      "effort": "5min",
      "where": "## Localisation\n\n```cpp\nswitch (scancode) {\n    case SDL_SCANCODE_A: return events::Key::A;\n    case SDL_SCANCODE_B: return events::Key::B;\n    // 50+ cases avec events::Key:: repete\n}\n```",
      "why": "## Pourquoi c'est suggere\n\nC++20 `using enum` reduit la verbosity.\n\n**Regle SonarQube** : cpp:S6004",
      "how": "## Comment corriger\n\n```cpp\nusing enum events::Key;\nswitch (scancode) {\n    case SDL_SCANCODE_A: return A;\n    // ...\n}\n```"
    },
    {
      "id": "SONAR-012",
      "source": ["sonarqube"],
      "title": "Reduce switch cases from 52 to at most 30",
      "severity": "Major",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sdl2/src/SDL2Window.cpp",
      "line": 15,
      "rule": "cpp:S1479",
      "effort": "30min",
      "where": "## Localisation\n\n```cpp\nstatic events::Key scancodeToKey(SDL_Scancode scancode)\n{\n    switch (scancode) {\n        // 52 cases\n    }\n}\n```",
      "why": "## Pourquoi c'est un probleme\n\n```mermaid\nmindmap\n  root((52 cases))\n    Problemes\n      Lisibilite faible\n      Maintenance difficile\n    Solutions\n      Lookup table\n      std::map\n```\n\n**Regle SonarQube** : cpp:S1479",
      "how": "## Comment corriger\n\nUtiliser une lookup table.\n\n```cpp\nstatic constexpr std::array<std::pair<SDL_Scancode, events::Key>, 52> keyMapping = {{...}};\n```"
    },
    {
      "id": "SONAR-013",
      "source": ["sonarqube"],
      "title": "Use in-class initializer for _renderer",
      "severity": "Major",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sdl2/src/SDL2Window.cpp",
      "line": 72,
      "rule": "cpp:S3230",
      "effort": "10min",
      "where": "## Localisation\n\n```cpp\nSDL2Window::SDL2Window(...)\n    : _window(nullptr), _renderer(nullptr), _isOpen(true)\n{\n```\n\nLes initialisations devraient etre in-class.",
      "why": "## Pourquoi c'est suggere\n\nLes initialisations in-class sont preferees depuis C++11.\n\n**Regle SonarQube** : cpp:S3230",
      "how": "## Comment corriger\n\n```cpp\n// Dans le header\nSDL_Renderer* _renderer = nullptr;\n```"
    },
    {
      "id": "SONAR-016",
      "source": ["sonarqube"],
      "title": "Define and throw a dedicated exception",
      "severity": "Major",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sdl2/src/SDL2Window.cpp",
      "line": 75,
      "rule": "cpp:S112",
      "effort": "20min",
      "where": "## Localisation\n\n```cpp\nif (SDL_Init(SDL_INIT_VIDEO) < 0) {\n    throw std::runtime_error(\"Failed to initialize SDL\");\n}\n```",
      "why": "## Pourquoi c'est suggere\n\nUtiliser une exception dediee pour un meilleur traitement d'erreur.\n\n```mermaid\ngraph TD\n    A[std::runtime_error] --> B[Traitement generique]\n    C[SDLInitException] --> D[Traitement specifique]\n    style D fill:#6f6\n```\n\n**Regle SonarQube** : cpp:S112",
      "how": "## Comment corriger\n\nCreer une exception dediee `graphics::SDLInitException`."
    },
    {
      "id": "SONAR-021",
      "source": ["sonarqube"],
      "title": "Replace void* with a more meaningful type (getNativeHandle)",
      "severity": "Critical",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sdl2/src/SDL2Window.cpp",
      "line": 150,
      "rule": "cpp:S5008",
      "effort": "10min",
      "where": "## Localisation\n\n```cpp\nvoid* SDL2Window::getNativeHandle()\n{\n    return _renderer;\n}\n```\n\n**Note** : Peut etre justifie pour l'abstraction multi-backend.",
      "why": "## Pourquoi c'est un probleme\n\nvoid* perd toute information de type.\n\n**Regle SonarQube** : cpp:S5008",
      "how": "## Comment corriger\n\nUtiliser std::any ou documenter pourquoi void* est necessaire."
    },
    {
      "id": "SONAR-022",
      "source": ["sonarqube"],
      "title": "Add comment explaining why method is empty (draw)",
      "severity": "Critical",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sdl2/src/SDL2Window.cpp",
      "line": 156,
      "rule": "cpp:S1186",
      "effort": "5min",
      "where": "## Localisation\n\n```cpp\nvoid SDL2Window::draw(const graphics::IDrawable& drawable)\n{\n    // VIDE - pas d'implementation\n}\n```",
      "why": "## Pourquoi c'est un probleme\n\nMethode vide sans explication.\n\n**Regle SonarQube** : cpp:S1186",
      "how": "## Comment corriger\n\n```cpp\nvoid SDL2Window::draw(const graphics::IDrawable&) {\n    // Not implemented: use specific draw methods\n    (void)drawable;\n}\n```"
    },
    {
      "id": "SONAR-023",
      "source": ["sonarqube"],
      "title": "Pass polymorphic object by reference to const",
      "severity": "Major",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sdl2/src/SDL2Window.cpp",
      "line": 166,
      "rule": "cpp:S1238",
      "effort": "5min",
      "where": "## Localisation\n\n```cpp\nvoid SDL2Window::drawImg(graphics::IDrawable drawable, ...)\n```\n\nPassage par valeur cause object slicing.",
      "why": "## Pourquoi c'est un probleme\n\n```mermaid\ngraph TD\n    A[Derived object] --> B[Pass by value]\n    B --> C[Only Base copied]\n    C --> D[Derived data LOST]\n    style D fill:#f66\n```\n\n**Regle SonarQube** : cpp:S1238",
      "how": "## Comment corriger\n\n```cpp\nvoid SDL2Window::drawImg(const graphics::IDrawable& drawable, ...)\n```"
    },
    {
      "id": "SONAR-024",
      "source": ["sonarqube"],
      "title": "Add comment explaining why method is empty (drawImg)",
      "severity": "Critical",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sdl2/src/SDL2Window.cpp",
      "line": 167,
      "rule": "cpp:S1186",
      "effort": "5min",
      "where": "## Localisation\n\n```cpp\nvoid SDL2Window::drawImg(...) {\n    // VIDE\n}\n```",
      "why": "## Pourquoi c'est un probleme\n\nMeme raison que SONAR-022.\n\n**Regle SonarQube** : cpp:S1186",
      "how": "## Comment corriger\n\nAjouter un commentaire explicatif."
    }
  ]
}
