{
  "agent": "sonar",
  "timestamp": "2025-12-18T10:00:00Z",
  "total_issues": 24,
  "enriched_issues": 24,
  "agentdb_queries": {
    "file_context": {"status": "not_indexed", "count": 0, "not_indexed": 5},
    "patterns": {"status": "not_indexed", "count": 0},
    "file_metrics": {"status": "not_indexed", "count": 0},
    "architecture_decisions": {"status": "not_indexed", "count": 0}
  },
  "summary": {
    "by_severity": {
      "Blocker": 0,
      "Critical": 9,
      "Major": 11,
      "Minor": 4,
      "Info": 0
    },
    "by_category": {
      "Maintainability": 23,
      "Reliability": 1,
      "Security": 0
    },
    "bugs_count": 1,
    "total_effort": "275min"
  },
  "issues": [
    {
      "id": "SONAR-001",
      "source": ["sonarqube"],
      "title": "Empty catch block should be documented",
      "severity": "Major",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/src/network/UDPClient.cpp",
      "line": 169,
      "rule": "cpp:S108",
      "effort": "5min",
      "agentdb_context": {
        "module": "client/network",
        "is_critical": true,
        "patterns_violated": [],
        "adr_applicable": null,
        "indexed": false
      },
      "where": "## Localisation\n\nLe probleme se trouve dans `src/client/src/network/UDPClient.cpp` a la ligne 169.\n\n```cpp\n// Lines 165-170 from UDPClient.cpp\nbool UDPClient::isConnected() const\n{\n    return _connected && _socket.is_open();\n}\n// Note: Line 169 in the original file appears to be within a conditional block\n// that may have an empty statement or comment\n```\n\n### Contexte du fichier\n\nCe fichier (`UDPClient.cpp`) implemente le client reseau UDP pour la communication avec le serveur de jeu. Il gere la connexion, la deconnexion, l'envoi de commandes (deplacement, tir) et la reception des mises a jour de l'etat du jeu (snapshots, missiles, joueurs).\n\n**Module** : client/network\n**Utilise par** : GameScene.cpp, scenes du jeu\n\n> **Note** : Fichier critique pour la synchronisation multijoueur.",
      "why": "## Pourquoi c'est un probleme\n\nUn bloc compound vide (accolades sans contenu) peut indiquer:\n- Du code incomplet ou oublie\n- Une intention non documentee\n- Un bug potentiel ou une logique manquante\n\n**Regle SonarQube** : [cpp:S108](https://rules.sonarsource.com/cpp/RSPEC-108)\n**Categorie** : Maintainability\n**Effort estime** : 5min\n\n### Visualisation du probleme\n\n```mermaid\nmindmap\n  root((Bloc vide))\n    Risques\n      Code incomplet\n      Intention floue\n      Bug potentiel\n    Maintenabilite\n      Confusion pour les developpeurs\n      Temps de comprehension eleve\n    Solutions\n      Ajouter commentaire\n      Implementer logique\n      Supprimer si inutile\n```\n\n### Impact\n\nUn bloc vide dans le code reseau critique peut masquer une logique manquante pour la gestion des erreurs ou des cas limites.",
      "how": "## Comment corriger\n\n### Solution recommandee\n\n1. **Si le bloc est intentionnellement vide**, ajouter un commentaire explicatif:\n```cpp\nif (condition) {\n    // Intentionally empty: no action needed for this case\n}\n```\n\n2. **Si du code manque**, implementer la logique appropriee\n\n3. **Si le bloc est inutile**, le supprimer completement\n\n### Ressources\n\n- [Documentation SonarQube cpp:S108](https://rules.sonarsource.com/cpp/RSPEC-108)"
    },
    {
      "id": "SONAR-002",
      "source": ["sonarqube"],
      "title": "Do not throw uncaught exceptions in a destructor",
      "severity": "Critical",
      "category": "Reliability",
      "status": "pending",
      "isBug": true,
      "file": "src/client/src/network/UDPClient.cpp",
      "line": 28,
      "rule": "cpp:S1048",
      "effort": "30min",
      "agentdb_context": {
        "module": "client/network",
        "is_critical": true,
        "patterns_violated": ["error_handling"],
        "adr_applicable": null,
        "indexed": false
      },
      "where": "## Localisation\n\nLe probleme se trouve dans `src/client/src/network/UDPClient.cpp` a la ligne 28.\n\n```cpp\n// Lines 26-29 from UDPClient.cpp\nUDPClient::~UDPClient()\n{\n    disconnect();  // Line 28 - peut lancer des exceptions\n}\n```\n\n### Contexte du fichier\n\nLe destructeur de `UDPClient` appelle `disconnect()` qui peut potentiellement lancer des exceptions via les operations Boost.ASIO ou les callbacks.\n\n**Module** : client/network\n**Classe** : UDPClient\n**Impact** : Crash potentiel de l'application",
      "why": "## Pourquoi c'est un probleme\n\nLancer une exception non capturee dans un destructeur est **extremement dangereux** en C++ :\n\n1. Si une exception est deja en cours de propagation, `std::terminate()` sera appele\n2. Cela peut causer des fuites de ressources\n3. Comportement indefini potentiel\n\n**Regle SonarQube** : [cpp:S1048](https://rules.sonarsource.com/cpp/RSPEC-1048)\n**Categorie** : Reliability\n**Severite** : Critical\n**Effort estime** : 30min\n\n### Visualisation du probleme\n\n```mermaid\ngraph TD\n    A[Exception active] --> B[Destructeur appele]\n    B --> C[disconnect() lance exception]\n    C --> D[Double exception!]\n    D --> E[std::terminate]\n    E --> F[CRASH APPLICATION]\n    style F fill:#f66,stroke:#333\n```\n\n### Impact\n\nCe bug peut causer un crash immediat de l'application cliente lors de la deconnexion, particulierement si une erreur reseau survient pendant le nettoyage.",
      "how": "## Comment corriger\n\n### Solution recommandee\n\nEncapsuler l'appel dans un try-catch et logger l'erreur:\n\n```cpp\nUDPClient::~UDPClient() noexcept\n{\n    try {\n        disconnect();\n    } catch (const std::exception& e) {\n        // Log the error but don't propagate\n        client::logging::Logger::getNetworkLogger()->error(\n            \"Exception in destructor: {}\", e.what());\n    } catch (...) {\n        // Catch any other exceptions\n        client::logging::Logger::getNetworkLogger()->error(\n            \"Unknown exception in destructor\");\n    }\n}\n```\n\n### Points importants\n\n1. Ajouter `noexcept` au destructeur pour garantir qu'il ne lance pas\n2. Logger toute exception plutot que de la propager\n3. Attraper aussi les exceptions non-standard avec `catch(...)`\n\n### Ressources\n\n- [Documentation SonarQube cpp:S1048](https://rules.sonarsource.com/cpp/RSPEC-1048)\n- [C++ Core Guidelines C.36](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c36-a-destructor-must-not-fail)"
    },
    {
      "id": "SONAR-003",
      "source": ["sonarqube"],
      "title": "Remove the unused lambda capture \"buf\"",
      "severity": "Minor",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/src/network/UDPClient.cpp",
      "line": 149,
      "rule": "cpp:S1481",
      "effort": "5min",
      "agentdb_context": {
        "module": "client/network",
        "is_critical": false,
        "patterns_violated": [],
        "adr_applicable": null,
        "indexed": false
      },
      "where": "## Localisation\n\nLe probleme se situe probablement dans une lambda de callback asynchrone. En regardant le pattern du fichier:\n\n```cpp\n// Pattern similaire dans asyncSendTo (lines 220-234)\nvoid UDPClient::asyncSendTo(std::shared_ptr<std::vector<uint8_t>>& buf, size_t totalSize) {\n    _socket.async_send_to(\n        boost::asio::buffer(buf->data(), totalSize),\n        _endpoint,\n        [buf](const boost::system::error_code &error, std::size_t) {\n            // buf est capture mais peut ne pas etre utilise dans certains cas\n            if (error) {\n                // ...\n            }\n        }\n    );\n}\n```\n\n### Contexte\n\nLa capture `buf` dans la lambda maintient le shared_ptr en vie pendant l'operation asynchrone. Bien que SonarQube signale une capture \"inutilisee\", elle est en fait necessaire pour la gestion de la duree de vie du buffer.",
      "why": "## Pourquoi c'est signale\n\nSonarQube detecte que la variable `buf` capturee dans la lambda n'est pas explicitement utilisee dans le corps de la lambda.\n\n**Regle SonarQube** : [cpp:S1481](https://rules.sonarsource.com/cpp/RSPEC-1481)\n**Categorie** : Maintainability\n**Severite** : Minor\n\n### Visualisation\n\n```mermaid\nmindmap\n  root((Capture inutilisee?))\n    Faux positif possible\n      Gestion lifetime RAII\n      shared_ptr maintenu\n    Si vraiment inutile\n      Supprimer capture\n      Reduire overhead\n```\n\n### Contexte important\n\nDans le contexte de Boost.ASIO, capturer le `shared_ptr<vector>` dans la lambda est une technique standard pour maintenir le buffer en vie pendant l'operation asynchrone. Ce n'est probablement **pas** un vrai probleme.",
      "how": "## Comment gerer\n\n### Option 1: Ajouter un attribut (faux positif)\n\nSi la capture est intentionnelle pour le lifetime:\n\n```cpp\n[buf]([[maybe_unused]] const boost::system::error_code &error, std::size_t) {\n    // buf keeps the buffer alive during async operation\n    (void)buf; // Explicitly mark as used for lifetime management\n    if (error) {\n        // ...\n    }\n}\n```\n\n### Option 2: Verifier si reellement inutile\n\nSi la capture n'est vraiment pas necessaire, la supprimer.\n\n### Ressources\n\n- [Documentation SonarQube cpp:S1481](https://rules.sonarsource.com/cpp/RSPEC-1481)"
    },
    {
      "id": "SONAR-004",
      "source": ["sonarqube"],
      "title": "Replace void* with a more meaningful type",
      "severity": "Critical",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/common/protocol/Protocol.hpp",
      "line": 88,
      "rule": "cpp:S5008",
      "effort": "10min",
      "agentdb_context": {
        "module": "common/protocol",
        "is_critical": true,
        "patterns_violated": ["type_safety"],
        "adr_applicable": null,
        "indexed": false
      },
      "where": "## Localisation\n\nLe probleme se trouve dans `src/common/protocol/Protocol.hpp` autour de la ligne 88.\n\n```cpp\n// Lines 83-94 from Protocol.hpp - UDPHeader::getTimestamp()\nstatic uint64_t getTimestamp() {\n    auto now = std::chrono::system_clock::now();\n\n    auto duration = now.time_since_epoch();\n\n    uint64_t milliseconds = std::chrono::duration_cast<std::chrono::milliseconds>(\n            duration)\n            .count();\n    return milliseconds;\n}\n```\n\nLe `void*` est utilise dans la signature de `to_bytes(void* buf)`:\n\n```cpp\n// Line 53 - to_bytes signature\nvoid to_bytes(void* buf) const {\n    auto* ptr = static_cast<uint8_t*>(buf);\n    // ...\n}\n```\n\n### Contexte\n\nLe fichier Protocol.hpp definit le protocole binaire UDP utilise pour la communication client-serveur. L'utilisation de `void*` permet une certaine flexibilite mais perd la securite de typage.",
      "why": "## Pourquoi c'est un probleme\n\nL'utilisation de `void*` pose plusieurs problemes:\n\n1. **Perte de type safety** : Le compilateur ne peut pas verifier les types\n2. **Erreurs silencieuses** : Passer le mauvais type ne genere pas d'erreur\n3. **Maintenabilite reduite** : Intention du code moins claire\n\n**Regle SonarQube** : [cpp:S5008](https://rules.sonarsource.com/cpp/RSPEC-5008)\n**Categorie** : Maintainability\n**Severite** : Critical\n\n### Visualisation du probleme\n\n```mermaid\ngraph TD\n    A[void* buf] --> B{Type reel?}\n    B -->|uint8_t*| C[OK]\n    B -->|char*| D[OK mais cast]\n    B -->|int*| E[BUG SILENCIEUX]\n    B -->|nullptr| F[CRASH]\n    style E fill:#f66\n    style F fill:#f66\n```\n\n### Impact sur le protocole\n\nDans un protocole reseau binaire, une erreur de typage peut causer:\n- Corruption de donnees\n- Problemes de parsing cote serveur\n- Vulnerabilites de securite",
      "how": "## Comment corriger\n\n### Solution recommandee\n\nUtiliser `uint8_t*` au lieu de `void*`:\n\n```cpp\n// AVANT\nvoid to_bytes(void* buf) const {\n    auto* ptr = static_cast<uint8_t*>(buf);\n    // ...\n}\n\n// APRES\nvoid to_bytes(uint8_t* buf) const {\n    // Plus besoin de cast!\n    uint16_t net_type = swap16(static_cast<uint16_t>(type));\n    std::memcpy(buf, &net_type, 2);\n    // ...\n}\n```\n\n### Alternative avec span (C++20)\n\n```cpp\nvoid to_bytes(std::span<uint8_t> buf) const {\n    if (buf.size() < WIRE_SIZE) {\n        throw std::runtime_error(\"Buffer too small\");\n    }\n    // ...\n}\n```\n\n### Ressources\n\n- [Documentation SonarQube cpp:S5008](https://rules.sonarsource.com/cpp/RSPEC-5008)"
    },
    {
      "id": "SONAR-005",
      "source": ["sonarqube"],
      "title": "Replace void* with a more meaningful type",
      "severity": "Critical",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/common/protocol/Protocol.hpp",
      "line": 182,
      "rule": "cpp:S5008",
      "effort": "10min",
      "agentdb_context": {
        "module": "common/protocol",
        "is_critical": true,
        "patterns_violated": ["type_safety"],
        "adr_applicable": null,
        "indexed": false
      },
      "where": "## Localisation\n\nLe probleme se trouve dans `src/common/protocol/Protocol.hpp` a la ligne 182.\n\n```cpp\n// Lines 180-198 from Protocol.hpp - MissileState::from_bytes\nstatic std::optional<MissileState> from_bytes(const void* buf, size_t buf_len) {\n    if (buf == nullptr || buf_len < WIRE_SIZE) return std::nullopt;\n    auto* ptr = static_cast<const uint8_t*>(buf);\n    MissileState ms;\n    uint16_t net_id, net_x, net_y;\n    std::memcpy(&net_id, ptr, 2);\n    ms.id = swap16(net_id);\n    ms.owner_id = ptr[2];\n    std::memcpy(&net_x, ptr + 3, 2);\n    std::memcpy(&net_y, ptr + 5, 2);\n    ms.x = swap16(net_x);\n    ms.y = swap16(net_y);\n    return ms;\n}\n```\n\n### Contexte\n\nMeme probleme que SONAR-004, mais pour la fonction `from_bytes` de parsing.",
      "why": "## Pourquoi c'est un probleme\n\nMeme raison que SONAR-004: `void*` perd la securite de typage.\n\n**Regle SonarQube** : [cpp:S5008](https://rules.sonarsource.com/cpp/RSPEC-5008)\n**Categorie** : Maintainability\n**Severite** : Critical\n\n### Impact specifique au parsing\n\nDans une fonction de parsing comme `from_bytes`, le risque est encore plus eleve car:\n- Les donnees viennent du reseau (non fiables)\n- Une erreur de type peut causer des lectures hors limites\n- Potentiel de vulnerabilite de securite",
      "how": "## Comment corriger\n\n### Solution recommandee\n\n```cpp\n// AVANT\nstatic std::optional<MissileState> from_bytes(const void* buf, size_t buf_len)\n\n// APRES\nstatic std::optional<MissileState> from_bytes(const uint8_t* buf, size_t buf_len)\n```\n\nOu avec span:\n\n```cpp\nstatic std::optional<MissileState> from_bytes(std::span<const uint8_t> buf)\n```\n\n### Ressources\n\n- [Documentation SonarQube cpp:S5008](https://rules.sonarsource.com/cpp/RSPEC-5008)"
    },
    {
      "id": "SONAR-006",
      "source": ["sonarqube"],
      "title": "Refactor to not nest more than 3 control statements",
      "severity": "Critical",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/server/infrastructure/adapters/in/network/UDPServer.cpp",
      "line": 79,
      "rule": "cpp:S134",
      "effort": "10min",
      "agentdb_context": {
        "module": "server/infrastructure/network",
        "is_critical": true,
        "patterns_violated": ["complexity"],
        "adr_applicable": null,
        "indexed": false
      },
      "where": "## Localisation\n\nLe probleme se trouve dans `src/server/infrastructure/adapters/in/network/UDPServer.cpp` autour de la ligne 79.\n\n```cpp\n// Lines 76-96 - sendPlayerLeave with nested structures\nvoid UDPServer::sendPlayerLeave(uint8_t playerId) {\n    const size_t totalSize = UDPHeader::WIRE_SIZE + PlayerLeave::WIRE_SIZE;\n    std::vector<uint8_t> buf(totalSize);\n\n    UDPHeader head{\n        .type = static_cast<uint16_t>(MessageType::PlayerLeave),\n        .sequence_num = 0,\n        .timestamp = UDPHeader::getTimestamp()\n    };\n    head.to_bytes(buf.data());\n\n    PlayerLeave pl{.player_id = playerId};\n    pl.to_bytes(buf.data() + UDPHeader::WIRE_SIZE);\n\n    auto endpoints = _gameWorld.getAllEndpoints();\n    for (const auto& ep : endpoints) {  // Boucle imbriquee\n        sendTo(ep, buf.data(), buf.size());\n    }\n    // ...\n}\n```\n\n### Contexte\n\nLe fichier UDPServer.cpp gere toute la logique reseau du serveur incluant la reception des messages, le broadcast des snapshots, et la gestion des evenements de jeu.",
      "why": "## Pourquoi c'est un probleme\n\nUn niveau d'imbrication superieur a 3 rend le code:\n- Difficile a lire et comprendre\n- Difficile a tester (nombreux chemins d'execution)\n- Prone aux erreurs lors des modifications\n\n**Regle SonarQube** : [cpp:S134](https://rules.sonarsource.com/cpp/RSPEC-134)\n**Categorie** : Maintainability\n**Severite** : Critical\n\n### Visualisation de la complexite\n\n```mermaid\nmindmap\n  root((Imbrication > 3))\n    Problemes\n      Lisibilite reduite\n      Tests complexes\n      Bugs potentiels\n    Causes\n      Logique trop concentree\n      Manque extraction methodes\n    Solutions\n      Early return\n      Extract method\n      Guard clauses\n```",
      "how": "## Comment corriger\n\n### Pattern: Early Return\n\n```cpp\nvoid UDPServer::sendPlayerLeave(uint8_t playerId) {\n    auto endpoints = _gameWorld.getAllEndpoints();\n    if (endpoints.empty()) return;  // Early return\n    \n    auto buf = buildPlayerLeaveMessage(playerId);\n    broadcastToAll(buf, endpoints);\n}\n```\n\n### Pattern: Extract Method\n\n```cpp\nstd::vector<uint8_t> UDPServer::buildPlayerLeaveMessage(uint8_t playerId) {\n    const size_t totalSize = UDPHeader::WIRE_SIZE + PlayerLeave::WIRE_SIZE;\n    std::vector<uint8_t> buf(totalSize);\n    // ... build message\n    return buf;\n}\n\nvoid UDPServer::broadcastToAll(const std::vector<uint8_t>& buf, \n                               const std::vector<udp::endpoint>& endpoints) {\n    for (const auto& ep : endpoints) {\n        sendTo(ep, buf.data(), buf.size());\n    }\n}\n```\n\n### Ressources\n\n- [Documentation SonarQube cpp:S134](https://rules.sonarsource.com/cpp/RSPEC-134)"
    },
    {
      "id": "SONAR-007",
      "source": ["sonarqube"],
      "title": "Merge this if statement with the enclosing one",
      "severity": "Major",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/server/infrastructure/adapters/in/network/UDPServer.cpp",
      "line": 79,
      "rule": "cpp:S1066",
      "effort": "5min",
      "agentdb_context": {
        "module": "server/infrastructure/network",
        "is_critical": false,
        "patterns_violated": [],
        "adr_applicable": null,
        "indexed": false
      },
      "where": "## Localisation\n\nLe probleme se trouve dans `src/server/infrastructure/adapters/in/network/UDPServer.cpp` a la ligne 79.\n\nPattern detecte:\n```cpp\n// Exemple de if imbriques fusionnables\nif (condition1) {\n    if (condition2) {\n        // action\n    }\n}\n// Peut etre simplifie en:\nif (condition1 && condition2) {\n    // action\n}\n```",
      "why": "## Pourquoi c'est un probleme\n\nDes `if` imbriques qui peuvent etre fusionnes:\n- Augmentent inutilement la complexite\n- Reduisent la lisibilite\n- Ajoutent des niveaux d'indentation\n\n**Regle SonarQube** : [cpp:S1066](https://rules.sonarsource.com/cpp/RSPEC-1066)\n**Categorie** : Maintainability\n**Severite** : Major\n\n### Visualisation\n\n```mermaid\ngraph LR\n    A[if A] --> B[if B]\n    B --> C[action]\n    D[if A && B] --> C\n    style D fill:#6f6\n```",
      "how": "## Comment corriger\n\nFusionner les conditions avec l'operateur `&&`:\n\n```cpp\n// AVANT\nif (error) {\n    if (error.value() != boost::asio::error::operation_aborted) {\n        handleError(error);\n    }\n}\n\n// APRES\nif (error && error.value() != boost::asio::error::operation_aborted) {\n    handleError(error);\n}\n```\n\n### Ressources\n\n- [Documentation SonarQube cpp:S1066](https://rules.sonarsource.com/cpp/RSPEC-1066)"
    },
    {
      "id": "SONAR-008",
      "source": ["sonarqube"],
      "title": "Use init-statement to declare variable inside if",
      "severity": "Minor",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sdl2/src/SDL2Window.cpp",
      "line": 131,
      "rule": "cpp:S6004",
      "effort": "2min",
      "agentdb_context": {
        "module": "client/graphics/sdl2",
        "is_critical": false,
        "patterns_violated": [],
        "adr_applicable": null,
        "indexed": false
      },
      "where": "## Localisation\n\nLe probleme se trouve dans `src/client/lib/sdl2/src/SDL2Window.cpp` autour de la ligne 131.\n\n```cpp\n// Lines 131-136 from SDL2Window.cpp - getSize()\nVec2u SDL2Window::getSize() const\n{\n    int w, h;  // Declaration separee\n    SDL_GetWindowSize(_window, &w, &h);\n    return Vec2u(static_cast<unsigned int>(w), static_cast<unsigned int>(h));\n}\n```\n\nEt dans pollEvent():\n```cpp\n// Lines 148-168 - pollEvent avec sdlEvent\nevents::Event SDL2Window::pollEvent()\n{\n    SDL_Event sdlEvent;  // Declaration avant le if\n    if (SDL_PollEvent(&sdlEvent)) {\n        // ...\n    }\n}\n```",
      "why": "## Pourquoi c'est suggere\n\nC++17 introduit les init-statements dans les `if` et `switch`, permettant de limiter la portee des variables.\n\n**Regle SonarQube** : [cpp:S6004](https://rules.sonarsource.com/cpp/RSPEC-6004)\n**Categorie** : Maintainability\n**Severite** : Minor\n\n### Avantages\n\n- Portee reduite = moins de risques d'erreurs\n- Code plus expressif\n- Intention plus claire",
      "how": "## Comment corriger\n\n### Utiliser l'init-statement C++17\n\n```cpp\n// AVANT\nevents::Event SDL2Window::pollEvent()\n{\n    SDL_Event sdlEvent;\n    if (SDL_PollEvent(&sdlEvent)) {\n        // use sdlEvent\n    }\n    return events::None{};\n}\n\n// APRES (C++17)\nevents::Event SDL2Window::pollEvent()\n{\n    if (SDL_Event sdlEvent; SDL_PollEvent(&sdlEvent)) {\n        // use sdlEvent - scope limited to if block\n    }\n    return events::None{};\n}\n```\n\n### Ressources\n\n- [Documentation SonarQube cpp:S6004](https://rules.sonarsource.com/cpp/RSPEC-6004)\n- [C++17 if/switch init-statements](https://en.cppreference.com/w/cpp/language/if#If_statements_with_initializer)"
    },
    {
      "id": "SONAR-009",
      "source": ["sonarqube"],
      "title": "Customize copy constructor for resource management (Rule of 5)",
      "severity": "Critical",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sdl2/include/SDL2Window.hpp",
      "line": 18,
      "rule": "cpp:S3624",
      "effort": "30min",
      "agentdb_context": {
        "module": "client/graphics/sdl2",
        "is_critical": true,
        "patterns_violated": ["rule_of_five"],
        "adr_applicable": null,
        "indexed": false
      },
      "where": "## Localisation\n\nLe probleme se trouve dans `src/client/lib/sdl2/include/SDL2Window.hpp` a la ligne 18.\n\n```cpp\n// Lines 18-52 from SDL2Window.hpp\nclass SDL2Window: public graphics::IWindow {\n    public:\n        SDL2Window(Vec2u winSize, const std::string& name);\n        ~SDL2Window();  // Destructeur custom\n\n        // MANQUANT: copy constructor, copy assignment\n        // MANQUANT: move constructor, move assignment\n\n    private:\n        SDL_Window* _window;       // Ressource geree\n        SDL_Renderer* _renderer;   // Ressource geree\n        bool _isOpen;\n        bool _ttfInitialized = false;\n        std::unordered_map<std::string, SDL_Texture*> _textures;  // Ressources\n        std::unordered_map<std::string, TTF_Font*> _fonts;        // Ressources\n};\n```\n\n### Contexte\n\nLa classe SDL2Window gere des ressources SDL natives (window, renderer, textures, fonts). Un destructeur custom est defini pour les liberer, mais les operations de copie/move ne sont pas definies.",
      "why": "## Pourquoi c'est un probleme\n\nLa **Rule of Five** en C++ stipule que si vous definissez l'une des operations suivantes, vous devriez probablement definir les 5:\n\n1. Destructeur\n2. Copy constructor\n3. Copy assignment operator\n4. Move constructor\n5. Move assignment operator\n\n**Regle SonarQube** : [cpp:S3624](https://rules.sonarsource.com/cpp/RSPEC-3624)\n**Categorie** : Maintainability\n**Severite** : Critical\n\n### Visualisation du risque\n\n```mermaid\ngraph TD\n    A[SDL2Window w1] --> B[SDL_Window*]\n    C[SDL2Window w2 = w1] --> B\n    D[w1 detruit] --> E[SDL_DestroyWindow]\n    F[w2 utilise] --> G[DANGLING POINTER!]\n    style G fill:#f66\n```\n\n### Impact\n\nSans operations de copie/move appropriees:\n- Double-free potentiel\n- Dangling pointers\n- Crash ou corruption memoire",
      "how": "## Comment corriger\n\n### Option 1: Desactiver copie (recommande)\n\n```cpp\nclass SDL2Window: public graphics::IWindow {\n    public:\n        SDL2Window(Vec2u winSize, const std::string& name);\n        ~SDL2Window();\n\n        // Disable copy\n        SDL2Window(const SDL2Window&) = delete;\n        SDL2Window& operator=(const SDL2Window&) = delete;\n\n        // Enable move\n        SDL2Window(SDL2Window&& other) noexcept;\n        SDL2Window& operator=(SDL2Window&& other) noexcept;\n    // ...\n};\n```\n\n### Option 2: Implementer move semantics\n\n```cpp\nSDL2Window::SDL2Window(SDL2Window&& other) noexcept\n    : _window(other._window)\n    , _renderer(other._renderer)\n    , _isOpen(other._isOpen)\n    , _textures(std::move(other._textures))\n    , _fonts(std::move(other._fonts))\n{\n    other._window = nullptr;\n    other._renderer = nullptr;\n    other._isOpen = false;\n}\n```\n\n### Ressources\n\n- [Documentation SonarQube cpp:S3624](https://rules.sonarsource.com/cpp/RSPEC-3624)\n- [C++ Core Guidelines C.21](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c21-if-you-define-or-delete-any-copy-move-or-destructor-function-define-or-delete-them-all)"
    },
    {
      "id": "SONAR-010",
      "source": ["sonarqube"],
      "title": "Annotate function with override or final",
      "severity": "Minor",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sdl2/include/SDL2Window.hpp",
      "line": 21,
      "rule": "cpp:S3471",
      "effort": "5min",
      "agentdb_context": {
        "module": "client/graphics/sdl2",
        "is_critical": false,
        "patterns_violated": [],
        "adr_applicable": null,
        "indexed": false
      },
      "where": "## Localisation\n\nLe probleme se trouve dans `src/client/lib/sdl2/include/SDL2Window.hpp` a la ligne 21.\n\n```cpp\n// Line 21 and following - virtual function declarations\nclass SDL2Window: public graphics::IWindow {\n    public:\n        // ...\n        Vec2u getSize() const override;  // OK\n        bool isOpen() override;          // OK\n        // ... certaines peuvent manquer override\n};\n```\n\nNote: En regardant le fichier, la plupart des methodes ont deja `override`. Verifier la ligne 21 specifiquement.",
      "why": "## Pourquoi c'est important\n\nL'attribut `override` permet au compilateur de verifier que la methode surcharge bien une methode virtuelle de la classe parente.\n\n**Regle SonarQube** : [cpp:S3471](https://rules.sonarsource.com/cpp/RSPEC-3471)\n**Categorie** : Maintainability\n**Severite** : Minor\n\n### Avantages de override\n\n- Erreur de compilation si signature incorrecte\n- Documentation implicite\n- Prevention des bugs subtils",
      "how": "## Comment corriger\n\nAjouter `override` a toutes les methodes virtuelles surchargees:\n\n```cpp\n// AVANT\nbool isOpen();\n\n// APRES\nbool isOpen() override;\n```\n\n### Ressources\n\n- [Documentation SonarQube cpp:S3471](https://rules.sonarsource.com/cpp/RSPEC-3471)"
    },
    {
      "id": "SONAR-011",
      "source": ["sonarqube"],
      "title": "Reduce verbosity with using enum",
      "severity": "Minor",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sdl2/src/SDL2Window.cpp",
      "line": 15,
      "rule": "cpp:S6004",
      "effort": "5min",
      "agentdb_context": {
        "module": "client/graphics/sdl2",
        "is_critical": false,
        "patterns_violated": [],
        "adr_applicable": null,
        "indexed": false
      },
      "where": "## Localisation\n\nLe probleme se trouve dans `src/client/lib/sdl2/src/SDL2Window.cpp` a la ligne 15.\n\n```cpp\n// Lines 15-71 - scancodeToKey function with many events::Key::\nstatic events::Key scancodeToKey(SDL_Scancode scancode)\n{\n    switch (scancode) {\n        case SDL_SCANCODE_A: return events::Key::A;\n        case SDL_SCANCODE_B: return events::Key::B;\n        case SDL_SCANCODE_C: return events::Key::C;\n        // ... 50+ cases avec events::Key:: repete\n    }\n}\n```\n\n### Contexte\n\nLa fonction mappe les scancodes SDL vers l'enum `events::Key` du projet. Chaque case repete le prefixe `events::Key::`.",
      "why": "## Pourquoi c'est suggere\n\nC++20 introduit `using enum` qui permet d'importer les enumerateurs dans la portee locale.\n\n**Regle SonarQube** : [cpp:S6004](https://rules.sonarsource.com/cpp/RSPEC-6004)\n**Categorie** : Maintainability\n**Severite** : Minor\n\n### Avantages\n\n- Code plus concis\n- Meilleure lisibilite\n- Moins de repetition",
      "how": "## Comment corriger\n\n### Utiliser using enum (C++20)\n\n```cpp\nstatic events::Key scancodeToKey(SDL_Scancode scancode)\n{\n    using enum events::Key;  // Import all enumerators\n    \n    switch (scancode) {\n        case SDL_SCANCODE_A: return A;  // Plus besoin de events::Key::\n        case SDL_SCANCODE_B: return B;\n        case SDL_SCANCODE_C: return C;\n        // ...\n    }\n}\n```\n\n### Note\n\nNecessite C++20. Le projet utilise C++23 donc compatible.\n\n### Ressources\n\n- [Documentation SonarQube cpp:S6004](https://rules.sonarsource.com/cpp/RSPEC-6004)"
    },
    {
      "id": "SONAR-012",
      "source": ["sonarqube"],
      "title": "Reduce switch cases from 52 to at most 30",
      "severity": "Major",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sdl2/src/SDL2Window.cpp",
      "line": 15,
      "rule": "cpp:S1479",
      "effort": "30min",
      "agentdb_context": {
        "module": "client/graphics/sdl2",
        "is_critical": false,
        "patterns_violated": ["complexity"],
        "adr_applicable": null,
        "indexed": false
      },
      "where": "## Localisation\n\nLe probleme se trouve dans `src/client/lib/sdl2/src/SDL2Window.cpp` a la ligne 15.\n\n```cpp\n// Lines 15-71 - Large switch statement\nstatic events::Key scancodeToKey(SDL_Scancode scancode)\n{\n    switch (scancode) {\n        case SDL_SCANCODE_A: return events::Key::A;\n        case SDL_SCANCODE_B: return events::Key::B;\n        // ... 52 cases au total\n        case SDL_SCANCODE_RALT: return events::Key::RAlt;\n        default: return events::Key::Unknown;\n    }\n}\n```\n\n### Contexte\n\nLa fonction mappe les 52 touches SDL vers l'enum du projet. Un switch de cette taille est difficile a maintenir.",
      "why": "## Pourquoi c'est un probleme\n\nUn switch avec plus de 30 cases est:\n- Difficile a lire et maintenir\n- Source d'erreurs lors de modifications\n- Signal d'un refactoring possible\n\n**Regle SonarQube** : [cpp:S1479](https://rules.sonarsource.com/cpp/RSPEC-1479)\n**Categorie** : Maintainability\n**Severite** : Major\n\n### Visualisation\n\n```mermaid\nmindmap\n  root((52 cases))\n    Problemes\n      Lisibilite faible\n      Maintenance difficile\n      Revue code penible\n    Solutions\n      Lookup table\n      std::map\n      Constexpr array\n```",
      "how": "## Comment corriger\n\n### Solution: Lookup Table\n\n```cpp\n#include <array>\n#include <utility>\n\nstatic constexpr std::array<std::pair<SDL_Scancode, events::Key>, 52> keyMapping = {{\n    {SDL_SCANCODE_A, events::Key::A},\n    {SDL_SCANCODE_B, events::Key::B},\n    // ...\n}};\n\nstatic events::Key scancodeToKey(SDL_Scancode scancode)\n{\n    for (const auto& [sdlKey, eventKey] : keyMapping) {\n        if (sdlKey == scancode) {\n            return eventKey;\n        }\n    }\n    return events::Key::Unknown;\n}\n```\n\n### Alternative: std::unordered_map\n\n```cpp\nstatic const std::unordered_map<SDL_Scancode, events::Key> keyMapping = {\n    {SDL_SCANCODE_A, events::Key::A},\n    // ...\n};\n\nstatic events::Key scancodeToKey(SDL_Scancode scancode)\n{\n    auto it = keyMapping.find(scancode);\n    return (it != keyMapping.end()) ? it->second : events::Key::Unknown;\n}\n```\n\n### Ressources\n\n- [Documentation SonarQube cpp:S1479](https://rules.sonarsource.com/cpp/RSPEC-1479)"
    },
    {
      "id": "SONAR-013",
      "source": ["sonarqube"],
      "title": "Use in-class initializer for _renderer",
      "severity": "Major",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sdl2/src/SDL2Window.cpp",
      "line": 72,
      "rule": "cpp:S3230",
      "effort": "10min",
      "agentdb_context": {
        "module": "client/graphics/sdl2",
        "is_critical": false,
        "patterns_violated": [],
        "adr_applicable": null,
        "indexed": false
      },
      "where": "## Localisation\n\nLe probleme se trouve dans `src/client/lib/sdl2/src/SDL2Window.cpp` a la ligne 72-74.\n\n```cpp\n// Lines 73-74 - Constructor initializer list\nSDL2Window::SDL2Window(Vec2u winSize, const std::string& name)\n    : _window(nullptr), _renderer(nullptr), _isOpen(true)\n{\n    // ...\n}\n```\n\nEt dans le header:\n```cpp\n// SDL2Window.hpp - member declarations\nprivate:\n    SDL_Window* _window;      // Pas d'initialisation in-class\n    SDL_Renderer* _renderer;  // Pas d'initialisation in-class\n    bool _isOpen;             // Pas d'initialisation in-class\n```",
      "why": "## Pourquoi c'est suggere\n\nLes initialisations in-class (depuis C++11) sont preferees car:\n- Valeur par defaut visible dans la declaration\n- Moins de repetition dans les constructeurs\n- Moins de risque d'oubli\n\n**Regle SonarQube** : [cpp:S3230](https://rules.sonarsource.com/cpp/RSPEC-3230)\n**Categorie** : Maintainability\n**Severite** : Major",
      "how": "## Comment corriger\n\n### Utiliser l'initialisation in-class\n\n```cpp\n// Dans SDL2Window.hpp\nprivate:\n    SDL_Window* _window = nullptr;      // Initialisation in-class\n    SDL_Renderer* _renderer = nullptr;  // Initialisation in-class\n    bool _isOpen = false;               // Valeur par defaut safe\n    bool _ttfInitialized = false;       // Deja fait!\n```\n\n### Puis simplifier le constructeur\n\n```cpp\nSDL2Window::SDL2Window(Vec2u winSize, const std::string& name)\n{\n    // _window, _renderer, _isOpen ont deja leurs valeurs par defaut\n    // Maintenant initialiser avec les vraies valeurs\n}\n```\n\n### Ressources\n\n- [Documentation SonarQube cpp:S3230](https://rules.sonarsource.com/cpp/RSPEC-3230)"
    },
    {
      "id": "SONAR-014",
      "source": ["sonarqube"],
      "title": "Use in-class initializer for _isOpen",
      "severity": "Major",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sdl2/src/SDL2Window.cpp",
      "line": 72,
      "rule": "cpp:S3230",
      "effort": "10min",
      "agentdb_context": {
        "module": "client/graphics/sdl2",
        "is_critical": false,
        "patterns_violated": [],
        "adr_applicable": null,
        "indexed": false
      },
      "where": "## Localisation\n\nMeme localisation que SONAR-013.\n\n```cpp\nSDL2Window::SDL2Window(Vec2u winSize, const std::string& name)\n    : _window(nullptr), _renderer(nullptr), _isOpen(true)  // _isOpen ici\n```",
      "why": "## Pourquoi c'est suggere\n\nMeme raison que SONAR-013: preferer l'initialisation in-class.\n\n**Regle SonarQube** : [cpp:S3230](https://rules.sonarsource.com/cpp/RSPEC-3230)",
      "how": "## Comment corriger\n\nVoir SONAR-013 - ces issues peuvent etre corrigees ensemble.\n\n```cpp\n// Dans le header\nbool _isOpen = true;  // ou false selon la valeur par defaut souhaitee\n```"
    },
    {
      "id": "SONAR-015",
      "source": ["sonarqube"],
      "title": "Use in-class initializer for _window",
      "severity": "Major",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sdl2/src/SDL2Window.cpp",
      "line": 72,
      "rule": "cpp:S3230",
      "effort": "10min",
      "agentdb_context": {
        "module": "client/graphics/sdl2",
        "is_critical": false,
        "patterns_violated": [],
        "adr_applicable": null,
        "indexed": false
      },
      "where": "## Localisation\n\nMeme localisation que SONAR-013.\n\n```cpp\nSDL2Window::SDL2Window(Vec2u winSize, const std::string& name)\n    : _window(nullptr), _renderer(nullptr), _isOpen(true)  // _window ici\n```",
      "why": "## Pourquoi c'est suggere\n\nMeme raison que SONAR-013.\n\n**Regle SonarQube** : [cpp:S3230](https://rules.sonarsource.com/cpp/RSPEC-3230)",
      "how": "## Comment corriger\n\nVoir SONAR-013.\n\n```cpp\n// Dans le header\nSDL_Window* _window = nullptr;\n```"
    },
    {
      "id": "SONAR-016",
      "source": ["sonarqube"],
      "title": "Define and throw a dedicated exception",
      "severity": "Major",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sdl2/src/SDL2Window.cpp",
      "line": 75,
      "rule": "cpp:S112",
      "effort": "20min",
      "agentdb_context": {
        "module": "client/graphics/sdl2",
        "is_critical": false,
        "patterns_violated": ["exception_handling"],
        "adr_applicable": null,
        "indexed": false
      },
      "where": "## Localisation\n\nLe probleme se trouve dans `src/client/lib/sdl2/src/SDL2Window.cpp` a la ligne 75-77.\n\n```cpp\n// Lines 76-78 from SDL2Window.cpp\nif (SDL_Init(SDL_INIT_VIDEO) < 0) {\n    throw std::runtime_error(\"Failed to initialize SDL: \" + std::string(SDL_GetError()));\n}\n```\n\n### Contexte\n\nLe constructeur lance `std::runtime_error` en cas d'echec d'initialisation SDL. Une exception generique rend le traitement d'erreur cote appelant moins precis.",
      "why": "## Pourquoi c'est suggere\n\nUtiliser des exceptions generiques comme `std::runtime_error`:\n- Rend difficile le catch specifique\n- Melange differents types d'erreurs\n- Perd le contexte semantique\n\n**Regle SonarQube** : [cpp:S112](https://rules.sonarsource.com/cpp/RSPEC-112)\n**Categorie** : Maintainability\n**Severite** : Major\n\n### Visualisation\n\n```mermaid\ngraph TD\n    A[std::runtime_error] --> B{catch?}\n    B -->|Toutes les erreurs| C[Traitement generique]\n    D[SDLInitException] --> E{catch?}\n    E -->|Specifique| F[Traitement specifique]\n    E -->|Autres| G[Propagation]\n    style F fill:#6f6\n```",
      "how": "## Comment corriger\n\n### Creer une exception dediee\n\n```cpp\n// Dans un header d'exceptions\nnamespace graphics {\n\nclass GraphicsException : public std::runtime_error {\npublic:\n    using std::runtime_error::runtime_error;\n};\n\nclass SDLInitException : public GraphicsException {\npublic:\n    SDLInitException(const std::string& msg)\n        : GraphicsException(\"SDL Init failed: \" + msg) {}\n};\n\nclass SDLWindowException : public GraphicsException {\npublic:\n    SDLWindowException(const std::string& msg)\n        : GraphicsException(\"SDL Window failed: \" + msg) {}\n};\n\n} // namespace graphics\n```\n\n### Utiliser l'exception dediee\n\n```cpp\nif (SDL_Init(SDL_INIT_VIDEO) < 0) {\n    throw graphics::SDLInitException(SDL_GetError());\n}\n```\n\n### Ressources\n\n- [Documentation SonarQube cpp:S112](https://rules.sonarsource.com/cpp/RSPEC-112)"
    },
    {
      "id": "SONAR-017",
      "source": ["sonarqube"],
      "title": "Define and throw a dedicated exception",
      "severity": "Major",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sdl2/src/SDL2Window.cpp",
      "line": 89,
      "rule": "cpp:S112",
      "effort": "20min",
      "agentdb_context": {
        "module": "client/graphics/sdl2",
        "is_critical": false,
        "patterns_violated": ["exception_handling"],
        "adr_applicable": null,
        "indexed": false
      },
      "where": "## Localisation\n\nLe probleme se trouve dans `src/client/lib/sdl2/src/SDL2Window.cpp` a la ligne 89-92.\n\n```cpp\n// Lines 89-92\nif (!_window) {\n    SDL_Quit();\n    throw std::runtime_error(\"Failed to create SDL window: \" + std::string(SDL_GetError()));\n}\n```",
      "why": "## Pourquoi c'est suggere\n\nMeme raison que SONAR-016: utiliser une exception dediee.\n\n**Regle SonarQube** : [cpp:S112](https://rules.sonarsource.com/cpp/RSPEC-112)",
      "how": "## Comment corriger\n\nUtiliser l'exception dediee definie dans SONAR-016:\n\n```cpp\nif (!_window) {\n    SDL_Quit();\n    throw graphics::SDLWindowException(SDL_GetError());\n}\n```"
    },
    {
      "id": "SONAR-018",
      "source": ["sonarqube"],
      "title": "Define and throw a dedicated exception",
      "severity": "Major",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sdl2/src/SDL2Window.cpp",
      "line": 96,
      "rule": "cpp:S112",
      "effort": "20min",
      "agentdb_context": {
        "module": "client/graphics/sdl2",
        "is_critical": false,
        "patterns_violated": ["exception_handling"],
        "adr_applicable": null,
        "indexed": false
      },
      "where": "## Localisation\n\nLe probleme se trouve dans `src/client/lib/sdl2/src/SDL2Window.cpp` a la ligne 95-99.\n\n```cpp\n// Lines 94-99\n_renderer = SDL_CreateRenderer(_window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);\nif (!_renderer) {\n    SDL_DestroyWindow(_window);\n    SDL_Quit();\n    throw std::runtime_error(\"Failed to create SDL renderer: \" + std::string(SDL_GetError()));\n}\n```",
      "why": "## Pourquoi c'est suggere\n\nMeme raison que SONAR-016.\n\n**Regle SonarQube** : [cpp:S112](https://rules.sonarsource.com/cpp/RSPEC-112)",
      "how": "## Comment corriger\n\n```cpp\nclass SDLRendererException : public graphics::GraphicsException { /*...*/ };\n\n// Usage\nif (!_renderer) {\n    SDL_DestroyWindow(_window);\n    SDL_Quit();\n    throw graphics::SDLRendererException(SDL_GetError());\n}\n```"
    },
    {
      "id": "SONAR-019",
      "source": ["sonarqube"],
      "title": "Define each identifier in a dedicated statement",
      "severity": "Minor",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sdl2/src/SDL2Window.cpp",
      "line": 113,
      "rule": "cpp:S1659",
      "effort": "5min",
      "agentdb_context": {
        "module": "client/graphics/sdl2",
        "is_critical": false,
        "patterns_violated": [],
        "adr_applicable": null,
        "indexed": false
      },
      "where": "## Localisation\n\nLe probleme se trouve dans `src/client/lib/sdl2/src/SDL2Window.cpp` autour de la ligne 113 (dans le destructeur ou autre fonction).\n\nPattern detecte:\n```cpp\nint w, h;  // Deux variables sur une ligne\n```\n\nDans getSize():\n```cpp\nVec2u SDL2Window::getSize() const\n{\n    int w, h;  // Line ~133\n    SDL_GetWindowSize(_window, &w, &h);\n    return Vec2u(...);\n}\n```",
      "why": "## Pourquoi c'est suggere\n\nDeclarer plusieurs variables sur une ligne:\n- Reduit la lisibilite\n- Peut masquer des erreurs de typage\n- Complique l'ajout de commentaires\n\n**Regle SonarQube** : [cpp:S1659](https://rules.sonarsource.com/cpp/RSPEC-1659)\n**Categorie** : Maintainability\n**Severite** : Minor",
      "how": "## Comment corriger\n\n```cpp\n// AVANT\nint w, h;\n\n// APRES\nint w = 0;\nint h = 0;\n```\n\n### Ressources\n\n- [Documentation SonarQube cpp:S1659](https://rules.sonarsource.com/cpp/RSPEC-1659)"
    },
    {
      "id": "SONAR-020",
      "source": ["sonarqube"],
      "title": "Use braces to initialize the aggregate",
      "severity": "Major",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sdl2/src/SDL2Window.cpp",
      "line": 115,
      "rule": "cpp:S6872",
      "effort": "1min",
      "agentdb_context": {
        "module": "client/graphics/sdl2",
        "is_critical": false,
        "patterns_violated": [],
        "adr_applicable": null,
        "indexed": false
      },
      "where": "## Localisation\n\nLe probleme se trouve probablement lors de l'initialisation d'une structure SDL.\n\n```cpp\n// Exemple dans drawRect (line 181)\nSDL_FRect rect = {x, y, width, height};  // Initialisation par accolades - OK\n```\n\nOu potentiellement:\n```cpp\nSDL_Color sdlColor = {r, g, b, a};  // Verifier si manque accolades externes\n```",
      "why": "## Pourquoi c'est suggere\n\nL'initialisation par accolades (`{}`) des agregats est preferee car:\n- Plus explicite\n- Prevention du narrowing implicit\n- Syntaxe moderne C++11+\n\n**Regle SonarQube** : [cpp:S6872](https://rules.sonarsource.com/cpp/RSPEC-6872)",
      "how": "## Comment corriger\n\nUtiliser l'initialisation par accolades:\n\n```cpp\n// APRES\nSDL_FRect rect{x, y, width, height};\n```"
    },
    {
      "id": "SONAR-021",
      "source": ["sonarqube"],
      "title": "Replace void* with a more meaningful type",
      "severity": "Critical",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sdl2/src/SDL2Window.cpp",
      "line": 150,
      "rule": "cpp:S5008",
      "effort": "10min",
      "agentdb_context": {
        "module": "client/graphics/sdl2",
        "is_critical": false,
        "patterns_violated": ["type_safety"],
        "adr_applicable": null,
        "indexed": false
      },
      "where": "## Localisation\n\nLe probleme se trouve dans `src/client/lib/sdl2/src/SDL2Window.cpp` a la ligne 170-173.\n\n```cpp\n// Lines 170-173 - getNativeHandle\nvoid* SDL2Window::getNativeHandle()\n{\n    return _renderer;  // Retourne void*\n}\n```\n\n### Contexte\n\nLa methode `getNativeHandle()` est definie dans l'interface `IWindow` et retourne `void*` pour permettre l'acces au handle natif de la fenetre de maniere generique.",
      "why": "## Pourquoi c'est un probleme\n\n`void*` perd toute information de type. Dans ce cas, c'est probablement un choix de design pour l'abstraction, mais cela reste risque.\n\n**Regle SonarQube** : [cpp:S5008](https://rules.sonarsource.com/cpp/RSPEC-5008)\n**Categorie** : Maintainability\n**Severite** : Critical\n\n### Contexte specifique\n\nDans une architecture multi-backend (SFML/SDL2), le `void*` peut etre justifie pour l'abstraction. Neanmoins, des alternatives plus typees existent.",
      "how": "## Comment corriger\n\n### Option 1: std::any (C++17)\n\n```cpp\nstd::any getNativeHandle() override {\n    return _renderer;\n}\n\n// Usage\nauto handle = window.getNativeHandle();\nauto* renderer = std::any_cast<SDL_Renderer*>(handle);\n```\n\n### Option 2: Template avec CRTP\n\n```cpp\ntemplate<typename Derived>\nclass IWindow {\n    auto getNativeHandle() {\n        return static_cast<Derived*>(this)->getNativeHandleImpl();\n    }\n};\n```\n\n### Note\n\nSi le design actuel est intentionnel pour l'abstraction multi-backend, documenter pourquoi `void*` est utilise.\n\n### Ressources\n\n- [Documentation SonarQube cpp:S5008](https://rules.sonarsource.com/cpp/RSPEC-5008)"
    },
    {
      "id": "SONAR-022",
      "source": ["sonarqube"],
      "title": "Add comment explaining why method is empty",
      "severity": "Critical",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sdl2/src/SDL2Window.cpp",
      "line": 156,
      "rule": "cpp:S1186",
      "effort": "5min",
      "agentdb_context": {
        "module": "client/graphics/sdl2",
        "is_critical": false,
        "patterns_violated": [],
        "adr_applicable": null,
        "indexed": false
      },
      "where": "## Localisation\n\nLe probleme se trouve dans `src/client/lib/sdl2/src/SDL2Window.cpp` a la ligne 175-177.\n\n```cpp\n// Lines 175-177 - Empty draw method\nvoid SDL2Window::draw(const graphics::IDrawable& drawable)\n{\n    // VIDE - pas d'implementation\n}\n```\n\n### Contexte\n\nLa methode `draw()` est requise par l'interface `IWindow` mais n'est pas implementee dans le backend SDL2. Le corps est vide sans explication.",
      "why": "## Pourquoi c'est un probleme\n\nUne methode vide peut indiquer:\n- Implementation incomplete/oubliee\n- Methode intentionnellement non-operationnelle\n- Bug ou feature manquante\n\nSans commentaire, impossible de savoir.\n\n**Regle SonarQube** : [cpp:S1186](https://rules.sonarsource.com/cpp/RSPEC-1186)\n**Categorie** : Maintainability\n**Severite** : Critical",
      "how": "## Comment corriger\n\n### Si intentionnellement vide:\n\n```cpp\nvoid SDL2Window::draw(const graphics::IDrawable& drawable)\n{\n    // Not implemented: SDL2 backend uses specific draw methods\n    // (drawRect, drawSprite, drawText) instead of generic IDrawable\n    (void)drawable;  // Suppress unused parameter warning\n}\n```\n\n### Si doit etre implemente:\n\n```cpp\nvoid SDL2Window::draw(const graphics::IDrawable& drawable)\n{\n    drawable.draw(*this);  // Implement actual drawing\n}\n```\n\n### Ressources\n\n- [Documentation SonarQube cpp:S1186](https://rules.sonarsource.com/cpp/RSPEC-1186)"
    },
    {
      "id": "SONAR-023",
      "source": ["sonarqube"],
      "title": "Pass polymorphic object by reference to const",
      "severity": "Major",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sdl2/src/SDL2Window.cpp",
      "line": 166,
      "rule": "cpp:S1238",
      "effort": "5min",
      "agentdb_context": {
        "module": "client/graphics/sdl2",
        "is_critical": false,
        "patterns_violated": [],
        "adr_applicable": null,
        "indexed": false
      },
      "where": "## Localisation\n\nLe probleme se trouve dans `src/client/lib/sdl2/src/SDL2Window.cpp` a la ligne 186.\n\n```cpp\n// Line 186 - drawImg signature\nvoid SDL2Window::drawImg(graphics::IDrawable drawable, float x, float y, float scaleX, float scaleY)\n{\n    // ...\n}\n```\n\n### Contexte\n\nLe parametre `drawable` est passe par valeur, ce qui pour un objet polymorphe cause le \"slicing\" et une copie inutile.",
      "why": "## Pourquoi c'est un probleme\n\nPasser un objet polymorphe par valeur cause:\n\n1. **Object slicing**: Seule la partie base est copiee, les membres derives sont perdus\n2. **Copie inutile**: Performance reduite\n3. **Perte du polymorphisme**: Les methodes virtuelles ne fonctionnent plus correctement\n\n**Regle SonarQube** : [cpp:S1238](https://rules.sonarsource.com/cpp/RSPEC-1238)\n**Categorie** : Maintainability\n**Severite** : Major\n\n### Visualisation du slicing\n\n```mermaid\ngraph TD\n    A[Derived object] --> B[Pass by value]\n    B --> C[Only Base copied]\n    C --> D[Derived data LOST]\n    style D fill:#f66\n```",
      "how": "## Comment corriger\n\nPasser par reference constante:\n\n```cpp\n// AVANT\nvoid SDL2Window::drawImg(graphics::IDrawable drawable, ...)\n\n// APRES\nvoid SDL2Window::drawImg(const graphics::IDrawable& drawable, ...)\n```\n\n### Note\n\nMettre aussi a jour la declaration dans le header et l'interface `IWindow`.\n\n### Ressources\n\n- [Documentation SonarQube cpp:S1238](https://rules.sonarsource.com/cpp/RSPEC-1238)"
    },
    {
      "id": "SONAR-024",
      "source": ["sonarqube"],
      "title": "Add comment explaining why method is empty",
      "severity": "Critical",
      "category": "Maintainability",
      "status": "pending",
      "isBug": false,
      "file": "src/client/lib/sdl2/src/SDL2Window.cpp",
      "line": 167,
      "rule": "cpp:S1186",
      "effort": "5min",
      "agentdb_context": {
        "module": "client/graphics/sdl2",
        "is_critical": false,
        "patterns_violated": [],
        "adr_applicable": null,
        "indexed": false
      },
      "where": "## Localisation\n\nLe probleme se trouve dans `src/client/lib/sdl2/src/SDL2Window.cpp` a la ligne 186-188.\n\n```cpp\n// Lines 186-188 - Empty drawImg method\nvoid SDL2Window::drawImg(graphics::IDrawable drawable, float x, float y, float scaleX, float scaleY)\n{\n    // VIDE - pas d'implementation\n}\n```\n\n### Contexte\n\nMeme probleme que SONAR-022: methode vide sans explication.",
      "why": "## Pourquoi c'est un probleme\n\nMeme raison que SONAR-022.\n\n**Regle SonarQube** : [cpp:S1186](https://rules.sonarsource.com/cpp/RSPEC-1186)",
      "how": "## Comment corriger\n\n```cpp\nvoid SDL2Window::drawImg(const graphics::IDrawable& drawable, float x, float y, float scaleX, float scaleY)\n{\n    // Not implemented: use drawSprite() for texture-based drawing in SDL2\n    (void)drawable;\n    (void)x; (void)y;\n    (void)scaleX; (void)scaleY;\n}\n```\n\n### Ressources\n\n- [Documentation SonarQube cpp:S1186](https://rules.sonarsource.com/cpp/RSPEC-1186)"
    }
  ]
}
