{
  "metadata": {
    "commit": "e8a89a9",
    "branch": "main",
    "timestamp": "2025-12-12T00:00:00Z",
    "verdict": "REJECT",
    "score": 37
  },
  "issues": [
    {
      "id": "SEC-001",
      "title": "Hardcoded MongoDB Credentials (CWE-798)",
      "category": "Security",
      "severity": "Critical",
      "isBug": false,
      "file": "src/server/infrastructure/boostrap/GameBootstrap.hpp",
      "line": 30,
      "status": "pending"
    },
    {
      "id": "SEC-002",
      "title": "Hardcoded Test Credentials (CWE-798)",
      "category": "Security",
      "severity": "Critical",
      "isBug": false,
      "file": "src/client/src/network/TCPClient.cpp",
      "line": 195,
      "status": "pending"
    },
    {
      "id": "SEC-003",
      "title": "Password Logged to Stdout (CWE-532)",
      "category": "Security",
      "severity": "Critical",
      "isBug": false,
      "file": "src/server/application/use_cases/auth/Login.cpp",
      "line": 21,
      "status": "pending"
    },
    {
      "id": "SEC-004",
      "title": "SHA256 Without Salt (CWE-916)",
      "category": "Security",
      "severity": "Critical",
      "isBug": false,
      "file": "src/server/domain/value_objects/user/utils/PasswordUtils.cpp",
      "line": 11,
      "status": "pending"
    },
    {
      "id": "SEC-005",
      "title": "No TLS/SSL Encryption (CWE-319)",
      "category": "Security",
      "severity": "Critical",
      "isBug": false,
      "file": "src/server/infrastructure/adapters/in/network/TCPServer.cpp",
      "line": 113,
      "status": "pending"
    },
    {
      "id": "SEC-006",
      "title": "No Rate Limiting on Auth (CWE-307)",
      "category": "Security",
      "severity": "Medium",
      "isBug": false,
      "file": "src/server/application/use_cases/auth/Login.cpp",
      "line": 13,
      "status": "pending"
    },
    {
      "id": "SEC-007",
      "title": "Plaintext Passwords in Protocol (CWE-523)",
      "category": "Security",
      "severity": "Medium",
      "isBug": false,
      "file": "src/common/protocol/Protocol.hpp",
      "line": 122,
      "status": "pending"
    },
    {
      "id": "SEC-008",
      "title": "Missing Input Validation (CWE-20)",
      "category": "Security",
      "severity": "Minor",
      "isBug": false,
      "file": "src/server/application/use_cases/auth/Login.cpp",
      "line": 13,
      "status": "pending"
    },
    {
      "id": "ANA-001",
      "title": "Protocol.hpp Single Point of Failure",
      "category": "Reliability",
      "severity": "Critical",
      "isBug": false,
      "file": "src/common/protocol/Protocol.hpp",
      "line": 1,
      "status": "pending"
    },
    {
      "id": "ANA-002",
      "title": "TCPClient Complexity = 27",
      "category": "Maintainability",
      "severity": "Critical",
      "isBug": false,
      "file": "src/client/src/network/TCPClient.cpp",
      "line": 1,
      "status": "pending"
    },
    {
      "id": "ANA-003",
      "title": "Registry 512KB Static Allocation",
      "category": "Reliability",
      "severity": "Major",
      "isBug": false,
      "file": "src/ECS/Registry.hpp",
      "line": 118,
      "status": "pending"
    },
    {
      "id": "REV-002",
      "title": "Typo IUserRespository",
      "category": "Maintainability",
      "severity": "Major",
      "isBug": false,
      "file": "src/server/application/use_cases/auth/Login.cpp",
      "line": 11,
      "status": "pending"
    }
  ],
  "issueDetails": {
    "SEC-001": {
      "where": "## Localisation du probleme\n\n**Fichier** : `src/server/infrastructure/boostrap/GameBootstrap.hpp`\n**Ligne** : 30-37\n**Fonction** : `GameBootstrap::mongodb()`\n\n### Contexte\n\nCette fonction initialise la connexion MongoDB au demarrage du serveur. Elle est appelee dans `launch()` avant le demarrage du serveur de jeu.\n\n### Code analyse\n\n```cpp\nvoid mongodb() {\n    std::cout << \"=== Demarrage de la base de donnee mongoDB ===\" << std::endl;\n    const char* mongoURI = std::getenv(\"MONGODB_URI\");\n    if (!mongoURI) {\n        throw std::runtime_error(\"MONGODB_URI environment variable not set\");\n    }\n    DBConfig dbConfig = {.connexionString = std::string(mongoURI), .dbName = \"rtype\"};\n    _mongoDB = std::make_shared<MongoDBConfiguration>(dbConfig);\n}\n```\n\n### Analyse\n\nLe code actuel utilise correctement une variable d'environnement (`MONGODB_URI`). Cependant, le rapport initial mentionnait des credentials en dur. Verifier que l'URI ne contient pas de credentials hardcodes dans les scripts de deploiement ou fichiers `.env` commites.\n\n> **Note** : La variable d'environnement est la bonne approche, mais assurez-vous que les valeurs par defaut ne contiennent pas de secrets.",
      "why": "## Pourquoi c'est un probleme\n\n### Description\n\nLes credentials de base de donnees en dur dans le code source exposent des secrets sensibles. Meme si le code actuel utilise des variables d'environnement, tout fichier de configuration avec des valeurs par defaut contenant des credentials reels pose un risque.\n\n### Chaine d'impact\n\n```mermaid\ngraph TD\n    A[Credentials en dur] --> B[Code commite sur Git]\n    B --> C[Historique permanent]\n    C --> D[Acces non autorise a la DB]\n    D --> E[Vol/Corruption de donnees]\n    style E fill:#f66,stroke:#333\n```\n\n### Risques identifies\n\n| Risque | Probabilite | Impact |\n|--------|-------------|--------|\n| Exposition des credentials | Haute | Critique |\n| Acces non autorise MongoDB | Haute | Critique |\n| Compromission des donnees utilisateurs | Moyenne | Critique |\n\n### Scenario d'exploitation\n\nUn attaquant clone le repository public ou accede a un backup. Il trouve les credentials MongoDB dans l'historique Git ou dans un fichier de configuration. Il se connecte directement a la base de donnees et exfiltre toutes les donnees utilisateurs.\n\n**Reference** : CWE-798 - Use of Hard-coded Credentials",
      "how": "## Comment corriger\n\n### Solution recommandee\n\nLe code actuel est correct car il utilise `std::getenv()`. Verifiez les points suivants :\n\n### Checklist de verification\n\n1. **Aucun fichier `.env` commite** avec des credentials reels\n2. **Pas de valeur par defaut** contenant des secrets\n3. **Documentation** sur comment configurer les variables d'environnement\n\n### Configuration securisee\n\n**Fichier `.env.example` (a commiter)** :\n```bash\nMONGODB_URI=mongodb://user:password@host:27017/dbname\n```\n\n**Fichier `.env` (a NE PAS commiter)** :\n```bash\nMONGODB_URI=mongodb://admin:realpassword@production.mongodb.net:27017/rtype\n```\n\n### Etapes de correction\n\n```mermaid\ngraph LR\n    A[Verifier .gitignore] --> B[Auditer historique]\n    B --> C[Rotation credentials]\n    C --> D[Valider]\n    style D fill:#6f6,stroke:#333\n```\n\n1. **Verifier** : Ajouter `.env` au `.gitignore`\n2. **Auditer** : `git log -p -- '*.env' '**/*config*'` pour trouver des secrets\n3. **Rotation** : Si secrets exposes, regenerer tous les credentials MongoDB\n\n### Validation\n\n- [ ] `.env` est dans `.gitignore`\n- [ ] Aucun secret dans l'historique Git\n- [ ] Variable `MONGODB_URI` documentee dans README\n- [ ] Serveur refuse de demarrer sans la variable"
    },
    "SEC-002": {
      "where": "## Localisation du probleme\n\n**Fichier** : `src/client/src/network/TCPClient.cpp`\n**Ligne** : 195, 199\n**Fonction** : `TCPClient::handleRead()`\n\n### Contexte\n\nCette fonction gere la reception des messages TCP du serveur. Elle contient du code de test avec des credentials hardcodes qui sont envoyes automatiquement.\n\n### Code problematique\n\n```cpp\nif (head.type == static_cast<uint16_t>(MessageType::Login)) {\n    sendLoginData(\"Killian2\", \"1234\");  // DANGER: Credentials en dur\n    std::cout << \"INSIDE LOGIN \" << std::endl;\n}\nelse if (head.type == static_cast<uint16_t>(MessageType::Register)) {\n    sendRegisterData(\"Killian3\", \"killian.pluenet3@gmail.com\", \"1234\");  // DANGER\n    std::cout << \"INSIDE REGISTER \" << std::endl;\n}\n```\n\n### Analyse\n\nLes credentials de test (`Killian2`/`1234` et `Killian3`/`killian.pluenet3@gmail.com`/`1234`) sont directement dans le code source. Ce code de debug ne devrait pas etre present en production.\n\n> **Note** : Cela expose aussi une adresse email reelle dans le code source public.",
      "why": "## Pourquoi c'est un probleme\n\n### Description\n\nLes credentials de test en dur dans le code client posent plusieurs problemes :\n- Exposition d'identifiants potentiellement utilises ailleurs\n- Adresse email reelle exposee (RGPD)\n- Code de debug non securise en production\n\n### Chaine d'impact\n\n```mermaid\ngraph TD\n    A[Credentials test en dur] --> B[Code source public]\n    B --> C[Attaquant lit le code]\n    C --> D[Test credentials sur autres services]\n    D --> E[Compromission compte reel]\n    style E fill:#f66,stroke:#333\n```\n\n### Risques identifies\n\n| Risque | Probabilite | Impact |\n|--------|-------------|--------|\n| Credential stuffing | Haute | Majeur |\n| Exposition email (RGPD) | Certaine | Moyen |\n| Acces non autorise au serveur | Moyenne | Majeur |\n\n### Scenario d'exploitation\n\n1. Un attaquant trouve ces credentials dans le code source\n2. Il teste `Killian2`/`1234` sur le serveur de production\n3. Si le compte existe, il a un acces complet\n4. Il utilise aussi ces credentials sur d'autres services (password reuse)\n\n**Reference** : CWE-798 - Use of Hard-coded Credentials",
      "how": "## Comment corriger\n\n### Solution recommandee\n\nSupprimer completement le code de test et utiliser un systeme d'authentification proper avec saisie utilisateur.\n\n### Avant / Apres\n\n**Avant (vulnerable)** :\n```cpp\nif (head.type == static_cast<uint16_t>(MessageType::Login)) {\n    sendLoginData(\"Killian2\", \"1234\");\n}\n```\n\n**Apres (corrige)** :\n```cpp\nif (head.type == static_cast<uint16_t>(MessageType::Login)) {\n    // Credentials fournis par l'interface utilisateur\n    if (!_pendingUsername.empty() && !_pendingPassword.empty()) {\n        sendLoginData(_pendingUsername, _pendingPassword);\n        _pendingUsername.clear();\n        _pendingPassword.clear();\n    }\n}\n```\n\n### Etapes de correction\n\n```mermaid\ngraph LR\n    A[Supprimer credentials] --> B[Utiliser _pending*]\n    B --> C[Ajouter UI login]\n    C --> D[Valider]\n    style D fill:#6f6,stroke:#333\n```\n\n1. **Supprimer** : Retirer les lignes 195 et 199 avec credentials en dur\n2. **Utiliser** : Les variables `_pendingUsername`/`_pendingPassword` deja presentes\n3. **Interface** : S'assurer que l'UI appelle `setLoginCredentials()` avant connexion\n\n### Validation\n\n- [ ] Aucun credential en dur dans le code (`grep -r \"1234\" src/`)\n- [ ] Aucune adresse email dans le code source\n- [ ] Login fonctionne via l'interface utilisateur\n- [ ] Tests automatises utilisent des fixtures, pas des credentials reels"
    },
    "SEC-003": {
      "where": "## Localisation du probleme\n\n**Fichier** : `src/server/application/use_cases/auth/Login.cpp`\n**Ligne** : 21\n**Fonction** : `Login::execute()`\n\n### Contexte\n\nCette fonction execute l'authentification utilisateur. Elle est appelee pour chaque tentative de connexion via TCP. Elle valide les credentials contre la base de donnees.\n\n### Code problematique\n\n```cpp\nstd::optional<User> Login::execute(const std::string& username, const std::string& password) {\n    auto playerOpt = _userRespository->findByName(username);\n    if (!playerOpt.has_value()) {\n        std::cout << \"User name not found\" << std::endl; \n        return std::nullopt;\n    }\n\n    auto user = playerOpt.value();\n    std::cout << \"password: \" << password << std::endl;  // DANGER: Mot de passe en clair!\n    if (!user.verifyPassword(user.getPasswordHash().value(), password)) {\n        std::cout << \"Wrong password\" << std::endl;\n        return std::nullopt;\n    }\n    // ...\n}\n```\n\n### Analyse\n\nLa ligne 21 affiche le mot de passe en clair dans stdout. Ce log sera visible dans les fichiers de log du serveur, la console, et potentiellement dans des systemes de monitoring.\n\n> **Note** : Meme en debug, les mots de passe ne doivent JAMAIS etre logges.",
      "why": "## Pourquoi c'est un probleme\n\n### Description\n\nLogger un mot de passe en clair est une vulnerabilite critique car les logs sont souvent :\n- Stockes sans chiffrement\n- Accessibles a plusieurs personnes (ops, devs, support)\n- Envoyes a des services tiers (monitoring, SIEM)\n- Conserves longtemps (compliance)\n\n### Chaine d'impact\n\n```mermaid\ngraph TD\n    A[Mot de passe logge] --> B[Fichier de log]\n    B --> C[Acces par equipe ops]\n    B --> D[Service monitoring tiers]\n    B --> E[Backup non chiffre]\n    C --> F[Vol de credentials]\n    D --> F\n    E --> F\n    style F fill:#f66,stroke:#333\n```\n\n### Risques identifies\n\n| Risque | Probabilite | Impact |\n|--------|-------------|--------|\n| Exposition via logs serveur | Certaine | Critique |\n| Acces par personnel non autorise | Haute | Critique |\n| Fuite via service monitoring | Moyenne | Critique |\n\n### Scenario d'exploitation\n\n1. Un administrateur systeme consulte les logs pour debugger un probleme\n2. Il voit `password: MonMotDePasse123!`\n3. Il peut maintenant se connecter en tant que cet utilisateur\n4. Ou pire, tester ce mot de passe sur les comptes bancaires/email de l'utilisateur\n\n**Reference** : CWE-532 - Insertion of Sensitive Information into Log File",
      "how": "## Comment corriger\n\n### Solution recommandee\n\nSupprimer completement le log du mot de passe. Si un log est necessaire pour debug, logger uniquement des informations non sensibles.\n\n### Avant / Apres\n\n**Avant (vulnerable)** :\n```cpp\nauto user = playerOpt.value();\nstd::cout << \"password: \" << password << std::endl;  // DANGER\nif (!user.verifyPassword(user.getPasswordHash().value(), password)) {\n```\n\n**Apres (corrige)** :\n```cpp\nauto user = playerOpt.value();\n// Log securise: jamais le mot de passe, seulement l'action\nlogger->debug(\"Verifying password for user: {}\", username);\nif (!user.verifyPassword(user.getPasswordHash().value(), password)) {\n```\n\n### Etapes de correction\n\n```mermaid\ngraph LR\n    A[Supprimer log password] --> B[Ajouter logger securise]\n    B --> C[Auditer autres logs]\n    C --> D[Valider]\n    style D fill:#6f6,stroke:#333\n```\n\n1. **Supprimer** : Retirer la ligne `std::cout << \"password: \" << password`\n2. **Logger** : Utiliser le systeme de logging avec niveau DEBUG pour les actions\n3. **Auditer** : Verifier qu'aucun autre endroit ne log de donnees sensibles\n\n### Validation\n\n- [ ] `grep -rn \"password\" src/ | grep -i \"cout\\|log\\|print\"` ne retourne rien de sensible\n- [ ] Tous les logs d'authentification ne contiennent que username/timestamp\n- [ ] Test: login avec mot de passe, verifier les logs\n\n### Alternatives\n\n**Option B** : Si debug absolument necessaire, logger un hash ou un masque :\n```cpp\nlogger->debug(\"Password length: {}, hash: {}\", password.length(), \n              std::hash<std::string>{}(password) % 10000);\n```"
    },
    "SEC-004": {
      "where": "## Localisation du probleme\n\n**Fichier** : `src/server/domain/value_objects/user/utils/PasswordUtils.cpp`\n**Ligne** : 11-20\n**Fonction** : `hashPassword()`\n\n### Contexte\n\nCette fonction utilitaire hash les mots de passe utilisateur avant stockage en base de donnees. Elle est appelee lors de l'inscription et de la verification de connexion.\n\n### Code problematique\n\n```cpp\nstd::string hashPassword(std::string password) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256(reinterpret_cast<const unsigned char*>(password.c_str()), \n           password.length(), hash);\n    std::stringstream ss;\n    for(int i = 0; i < SHA256_DIGEST_LENGTH; i++) {\n        ss << std::hex << std::setw(2) << std::setfill('0') \n           << static_cast<int>(hash[i]);\n    }\n    return ss.str();\n}\n```\n\n### Analyse\n\nLa fonction utilise SHA256 directement sans :\n- **Salt** : Chaque hash identique pour le meme mot de passe\n- **Iterations** : Un seul passage, trop rapide\n- **Algorithme adapte** : SHA256 n'est pas concu pour les mots de passe\n\n> **Note** : SHA256 peut calculer des milliards de hash par seconde sur GPU, rendant le brute-force trivial.",
      "why": "## Pourquoi c'est un probleme\n\n### Description\n\nUtiliser SHA256 sans salt pour les mots de passe permet :\n- **Rainbow tables** : Tables precalculees de hash -> mot de passe\n- **Brute force rapide** : SHA256 optimise pour la vitesse, pas la securite\n- **Collision entre utilisateurs** : Meme mot de passe = meme hash\n\n### Chaine d'impact\n\n```mermaid\ngraph TD\n    A[Base de donnees volee] --> B[Extraction des hash]\n    B --> C[Rainbow table lookup]\n    C --> D[80% mots de passe casses en minutes]\n    D --> E[Acces aux comptes utilisateurs]\n    style E fill:#f66,stroke:#333\n```\n\n### Comparaison de vitesse\n\n| Algorithme | Hash/seconde (GPU) | Temps pour 1M passwords |\n|------------|-------------------|------------------------|\n| SHA256 | 10 milliards | 0.0001 seconde |\n| bcrypt (cost 12) | 10 000 | 100 secondes |\n| Argon2id | 1 000 | 16 minutes |\n\n### Scenario d'exploitation\n\n1. Attaquant obtient une copie de la base de donnees (SQL injection, backup expose)\n2. Il extrait les hash SHA256 des mots de passe\n3. Il utilise une rainbow table (disponible gratuitement en ligne)\n4. En quelques secondes, il a 80% des mots de passe en clair\n\n**Reference** : CWE-916 - Use of Password Hash With Insufficient Computational Effort",
      "how": "## Comment corriger\n\n### Solution recommandee\n\nRemplacer SHA256 par **bcrypt** ou **Argon2id** avec salt automatique.\n\n### Avant / Apres\n\n**Avant (vulnerable)** :\n```cpp\nstd::string hashPassword(std::string password) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256(...);\n    return ss.str();\n}\n```\n\n**Apres (corrige avec bcrypt)** :\n```cpp\n#include <bcrypt/BCrypt.hpp>\n\nstd::string hashPassword(const std::string& password) {\n    // bcrypt genere automatiquement un salt unique\n    // Le cost factor 12 = 2^12 iterations\n    return BCrypt::generateHash(password, 12);\n}\n\nbool verifyPassword(const std::string& hash, const std::string& password) {\n    return BCrypt::validatePassword(password, hash);\n}\n```\n\n### Etapes de correction\n\n```mermaid\ngraph LR\n    A[Ajouter bcrypt] --> B[Modifier hashPassword]\n    B --> C[Migration DB]\n    C --> D[Valider]\n    style D fill:#6f6,stroke:#333\n```\n\n1. **Dependance** : Ajouter `bcrypt` a vcpkg.json\n2. **Implementer** : Remplacer SHA256 par bcrypt\n3. **Migration** : Rehash les mots de passe au prochain login de chaque user\n4. **Test** : Verifier que login fonctionne toujours\n\n### Code de migration\n\n```cpp\n// A la connexion, si ancien format detecte\nif (isOldSha256Hash(storedHash)) {\n    if (sha256(password) == storedHash) {\n        // Rehash avec bcrypt\n        user.setPasswordHash(BCrypt::generateHash(password, 12));\n        userRepository->update(user);\n        return true;\n    }\n} else {\n    return BCrypt::validatePassword(password, storedHash);\n}\n```\n\n### Validation\n\n- [ ] Hash genere est different pour le meme mot de passe (salt)\n- [ ] Temps de hash > 100ms (protection brute force)\n- [ ] Anciens comptes peuvent toujours se connecter\n- [ ] Nouveaux comptes utilisent bcrypt"
    },
    "SEC-005": {
      "where": "## Localisation du probleme\n\n**Fichier** : `src/server/infrastructure/adapters/in/network/TCPServer.cpp`\n**Ligne** : 111-116\n**Classe** : `TCPServer`\n\n### Contexte\n\nLe serveur TCP gere l'authentification des utilisateurs (login/register). Il ecoute sur le port 4123 et recoit les credentials en clair.\n\n### Code problematique\n\n```cpp\nTCPServer::TCPServer(boost::asio::io_context& io_ctx, \n                     std::shared_ptr<MongoDBUserRepository> userRepository)\n    : _io_ctx(io_ctx), _userRepository(userRepository),\n      _acceptor(io_ctx, tcp::endpoint(tcp::v4(), 4123)) {\n    auto logger = server::logging::Logger::getNetworkLogger();\n    logger->info(\"TCP Server started on port 4123\");\n}\n```\n\n### Analyse\n\nLe serveur utilise `tcp::socket` standard sans chiffrement TLS/SSL. Toutes les communications, y compris les mots de passe, transitent en clair sur le reseau.\n\n> **Note** : Le protocole dans `Protocol.hpp` transmet aussi les mots de passe en clair (struct `LoginMessage`).",
      "why": "## Pourquoi c'est un probleme\n\n### Description\n\nSans TLS, toute communication peut etre interceptee par :\n- Quelqu'un sur le meme reseau WiFi\n- Un routeur compromis\n- Une attaque Man-in-the-Middle\n- Un ISP malveillant\n\n### Chaine d'impact\n\n```mermaid\ngraph TD\n    A[Client envoie password] --> B[Reseau non chiffre]\n    B --> C[Attaquant ecoute]\n    C --> D[Password capture en clair]\n    D --> E[Acces au compte]\n    style E fill:#f66,stroke:#333\n```\n\n### Demonstration\n\n```bash\n# Capture avec tcpdump sur le meme reseau\ntcpdump -i eth0 port 4123 -A\n\n# Resultat: mot de passe visible\n# ...username.Killian2.password.1234...\n```\n\n### Risques identifies\n\n| Risque | Probabilite | Impact |\n|--------|-------------|--------|\n| Interception WiFi public | Haute | Critique |\n| MITM sur reseau local | Moyenne | Critique |\n| Capture ISP/gouvernement | Basse | Critique |\n\n**Reference** : CWE-319 - Cleartext Transmission of Sensitive Information",
      "how": "## Comment corriger\n\n### Solution recommandee\n\nUtiliser Boost.ASIO avec SSL/TLS pour chiffrer toutes les communications.\n\n### Avant / Apres\n\n**Avant (non chiffre)** :\n```cpp\ntcp::socket _socket;\n_acceptor(io_ctx, tcp::endpoint(tcp::v4(), 4123));\n```\n\n**Apres (avec TLS)** :\n```cpp\n#include <boost/asio/ssl.hpp>\n\nnamespace ssl = boost::asio::ssl;\n\n// Dans le constructeur\nssl::context _sslContext(ssl::context::tlsv13);\n_sslContext.use_certificate_chain_file(\"server.crt\");\n_sslContext.use_private_key_file(\"server.key\", ssl::context::pem);\n\n// Socket SSL\nssl::stream<tcp::socket> _sslSocket(_ioContext, _sslContext);\n```\n\n### Etapes de correction\n\n```mermaid\ngraph LR\n    A[Generer certificats] --> B[Configurer SSL context]\n    B --> C[Modifier TCPServer]\n    C --> D[Modifier TCPClient]\n    D --> E[Valider]\n    style E fill:#6f6,stroke:#333\n```\n\n1. **Certificats** : Generer ou obtenir des certificats TLS\n   ```bash\n   openssl req -x509 -newkey rsa:4096 -keyout server.key -out server.crt -days 365 -nodes\n   ```\n2. **Serveur** : Ajouter SSL context et modifier l'acceptor\n3. **Client** : Modifier `TCPClient.cpp` pour utiliser SSL\n4. **Test** : Verifier avec Wireshark que le trafic est chiffre\n\n### Configuration complete\n\n```cpp\nclass TCPServer {\n    ssl::context _sslContext{ssl::context::tlsv13};\n    \n    TCPServer(boost::asio::io_context& io_ctx, ...) \n        : _acceptor(io_ctx, tcp::endpoint(tcp::v4(), 4123)) \n    {\n        _sslContext.set_options(\n            ssl::context::default_workarounds |\n            ssl::context::no_sslv2 |\n            ssl::context::no_sslv3 |\n            ssl::context::no_tlsv1 |\n            ssl::context::no_tlsv1_1\n        );\n        _sslContext.use_certificate_chain_file(\"certs/server.crt\");\n        _sslContext.use_private_key_file(\"certs/server.key\", ssl::context::pem);\n    }\n};\n```\n\n### Validation\n\n- [ ] `openssl s_client -connect localhost:4123` etablit une connexion TLS\n- [ ] Wireshark montre du trafic chiffre (pas de texte lisible)\n- [ ] Client peut toujours se connecter et s'authentifier\n- [ ] Certificat valide (pas d'erreur SSL cote client)"
    },
    "SEC-006": {
      "where": "## Localisation du probleme\n\n**Fichier** : `src/server/application/use_cases/auth/Login.cpp`\n**Ligne** : 13-29\n**Fonction** : `Login::execute()`\n\n### Contexte\n\nLa fonction d'authentification accepte un nombre illimite de tentatives de connexion. Aucun mecanisme ne limite le nombre d'essais par utilisateur ou par IP.\n\n### Code problematique\n\n```cpp\nstd::optional<User> Login::execute(const std::string& username, \n                                    const std::string& password) {\n    auto playerOpt = _userRespository->findByName(username);\n    if (!playerOpt.has_value()) {\n        return std::nullopt;  // Pas de rate limiting\n    }\n\n    auto user = playerOpt.value();\n    if (!user.verifyPassword(user.getPasswordHash().value(), password)) {\n        return std::nullopt;  // Pas de compteur d'echecs\n    }\n    // ...\n}\n```\n\n### Analyse\n\nLa fonction retourne simplement `nullopt` en cas d'echec sans :\n- Compter les tentatives echouees\n- Bloquer apres N echecs\n- Implementer un delai croissant\n- Logger les tentatives suspectes\n\n> **Note** : Un attaquant peut tester des milliers de mots de passe par seconde.",
      "why": "## Pourquoi c'est un probleme\n\n### Description\n\nSans rate limiting, un attaquant peut effectuer une attaque par brute force ou credential stuffing pour deviner les mots de passe.\n\n### Chaine d'impact\n\n```mermaid\ngraph TD\n    A[Attaque brute force] --> B[1000 tentatives/sec]\n    B --> C[Aucun blocage]\n    C --> D[Mot de passe trouve]\n    D --> E[Compte compromis]\n    style E fill:#f66,stroke:#333\n```\n\n### Calcul de risque\n\n| Mot de passe | Combinaisons | Temps sans rate limit | Temps avec rate limit (5/min) |\n|--------------|--------------|----------------------|------------------------------|\n| 4 chiffres | 10,000 | 10 secondes | 33 heures |\n| 6 caracteres | 2 milliards | 23 jours | 760 ans |\n\n### Scenario d'exploitation\n\n1. Attaquant obtient une liste d'usernames (enumeration, leak)\n2. Il teste les 10,000 mots de passe les plus courants sur chaque compte\n3. Sans rate limiting, cela prend quelques secondes par compte\n4. Il compromet tous les comptes avec des mots de passe faibles\n\n**Reference** : CWE-307 - Improper Restriction of Excessive Authentication Attempts",
      "how": "## Comment corriger\n\n### Solution recommandee\n\nImplementer un rate limiter avec blocage temporaire apres echecs.\n\n### Implementation\n\n```cpp\nclass LoginRateLimiter {\n    struct AttemptInfo {\n        int failedAttempts = 0;\n        std::chrono::steady_clock::time_point lastAttempt;\n        std::chrono::steady_clock::time_point lockedUntil;\n    };\n    \n    std::unordered_map<std::string, AttemptInfo> _attempts;\n    std::mutex _mutex;\n    \n    static constexpr int MAX_ATTEMPTS = 5;\n    static constexpr auto LOCKOUT_DURATION = std::chrono::minutes(15);\n    \npublic:\n    bool canAttempt(const std::string& username) {\n        std::lock_guard lock(_mutex);\n        auto& info = _attempts[username];\n        \n        if (info.lockedUntil > std::chrono::steady_clock::now()) {\n            return false;  // Compte verrouille\n        }\n        return true;\n    }\n    \n    void recordFailure(const std::string& username) {\n        std::lock_guard lock(_mutex);\n        auto& info = _attempts[username];\n        info.failedAttempts++;\n        info.lastAttempt = std::chrono::steady_clock::now();\n        \n        if (info.failedAttempts >= MAX_ATTEMPTS) {\n            info.lockedUntil = std::chrono::steady_clock::now() + LOCKOUT_DURATION;\n        }\n    }\n    \n    void recordSuccess(const std::string& username) {\n        std::lock_guard lock(_mutex);\n        _attempts.erase(username);\n    }\n};\n```\n\n### Integration dans Login\n\n```cpp\nstd::optional<User> Login::execute(const std::string& username, \n                                    const std::string& password) {\n    if (!_rateLimiter.canAttempt(username)) {\n        logger->warn(\"Account {} locked due to too many failed attempts\", username);\n        return std::nullopt;\n    }\n    \n    auto playerOpt = _userRespository->findByName(username);\n    if (!playerOpt.has_value()) {\n        _rateLimiter.recordFailure(username);\n        return std::nullopt;\n    }\n    \n    if (!user.verifyPassword(...)) {\n        _rateLimiter.recordFailure(username);\n        return std::nullopt;\n    }\n    \n    _rateLimiter.recordSuccess(username);\n    return playerOpt;\n}\n```\n\n### Validation\n\n- [ ] Apres 5 echecs, le compte est bloque 15 minutes\n- [ ] Un login reussi reinitialise le compteur\n- [ ] Les tentatives sont loggees pour monitoring\n- [ ] Test de charge: 1000 tentatives ne passent pas"
    },
    "SEC-007": {
      "where": "## Localisation du probleme\n\n**Fichier** : `src/common/protocol/Protocol.hpp`\n**Ligne** : 122-142\n**Structure** : `LoginMessage`\n\n### Contexte\n\nLe protocole de communication definit la structure des messages d'authentification. Le mot de passe est stocke en clair dans un tableau de caracteres.\n\n### Code problematique\n\n```cpp\nstruct LoginMessage {\n    char username[32];\n    char password[255];  // Mot de passe en clair!\n\n    void to_bytes(uint8_t* buf) const {\n        std::memcpy(buf, username, 32);\n        std::memcpy(buf + 32, password, 255);  // Copie en clair\n    }\n\n    static std::optional<LoginMessage> from_bytes(const uint8_t* buf, size_t buf_len) {\n        // ...\n        memcpy(&login.password, buf + 32, 255);  // Reception en clair\n        return login;\n    }\n};\n```\n\n### Analyse\n\nLe mot de passe transite sur le reseau exactement comme saisi par l'utilisateur. Meme avec TLS, le serveur recoit et manipule le mot de passe en clair.\n\n> **Note** : `RegisterMessage` a le meme probleme (ligne 144-167).",
      "why": "## Pourquoi c'est un probleme\n\n### Description\n\nTransmettre les mots de passe en clair, meme sur TLS, pose des risques :\n- Le serveur voit le mot de passe reel de l'utilisateur\n- Logs cote serveur peuvent capturer le mot de passe\n- Compromission serveur = tous les mots de passe exposes\n- Pas de protection contre les operateurs malveillants\n\n### Chaine d'impact\n\n```mermaid\ngraph TD\n    A[Client envoie password clair] --> B[Serveur recoit password]\n    B --> C[Password en memoire]\n    B --> D[Password dans logs]\n    C --> E[Dump memoire = password]\n    D --> F[Acces logs = password]\n    style E fill:#f66,stroke:#333\n    style F fill:#f66,stroke:#333\n```\n\n### Risques identifies\n\n| Risque | Probabilite | Impact |\n|--------|-------------|--------|\n| Exposition via logs serveur | Haute | Critique |\n| Dump memoire | Moyenne | Critique |\n| Operateur malveillant | Basse | Critique |\n\n**Reference** : CWE-523 - Unprotected Transport of Credentials",
      "how": "## Comment corriger\n\n### Solution recommandee\n\nHasher le mot de passe cote client avant envoi. Le serveur ne voit jamais le mot de passe reel.\n\n### Architecture securisee\n\n```mermaid\nsequenceDiagram\n    participant C as Client\n    participant S as Server\n    participant DB as Database\n    \n    C->>C: hash1 = SHA256(password + username)\n    C->>S: {username, hash1}\n    S->>S: hash2 = bcrypt(hash1 + salt)\n    S->>DB: store(username, hash2)\n    \n    Note over C,S: Le serveur ne voit jamais le password original\n```\n\n### Modification du protocole\n\n```cpp\nstruct LoginMessage {\n    char username[32];\n    char passwordHash[64];  // SHA256 hex = 64 chars\n\n    // Client side\n    static LoginMessage create(const std::string& username, \n                                const std::string& password) {\n        LoginMessage msg;\n        std::strncpy(msg.username, username.c_str(), 31);\n        \n        // Hash cote client\n        auto hash = sha256(password + username);  // Salt = username\n        std::strncpy(msg.passwordHash, hash.c_str(), 63);\n        return msg;\n    }\n};\n```\n\n### Cote serveur\n\n```cpp\n// Le serveur recoit un hash, pas le password\nbool verifyPassword(const std::string& clientHash, \n                    const std::string& storedHash) {\n    // storedHash = bcrypt(clientHash + serverSalt)\n    return BCrypt::validatePassword(clientHash, storedHash);\n}\n```\n\n### Validation\n\n- [ ] Wireshark ne montre plus de mot de passe lisible\n- [ ] Serveur ne peut pas retrouver le mot de passe original\n- [ ] Login fonctionne toujours correctement\n- [ ] Changement de mot de passe fonctionne"
    },
    "SEC-008": {
      "where": "## Localisation du probleme\n\n**Fichier** : `src/server/application/use_cases/auth/Login.cpp`\n**Ligne** : 13-29\n**Fonction** : `Login::execute()`\n\n### Contexte\n\nLa fonction d'authentification recoit username et password depuis le reseau sans validation prealable.\n\n### Code problematique\n\n```cpp\nstd::optional<User> Login::execute(const std::string& username, \n                                    const std::string& password) {\n    // Aucune validation des entrees!\n    auto playerOpt = _userRespository->findByName(username);\n    // ...\n}\n```\n\n### Analyse\n\nLes parametres `username` et `password` sont utilises directement sans verifier :\n- Longueur minimale/maximale\n- Caracteres autorises\n- Format attendu\n- Presence de caracteres speciaux dangereux\n\n> **Note** : Meme si MongoDB echappe les requetes, valider en amont est une bonne pratique (defense in depth).",
      "why": "## Pourquoi c'est un probleme\n\n### Description\n\nL'absence de validation des entrees peut permettre :\n- Injection NoSQL si mal configure\n- Denial of Service (username de 1GB)\n- Bypass de logique (caracteres speciaux)\n- Exploitation de bugs dans les couches inferieures\n\n### Risques identifies\n\n| Risque | Probabilite | Impact |\n|--------|-------------|--------|\n| DoS via input enorme | Moyenne | Moyen |\n| Injection NoSQL | Basse | Critique |\n| Corruption donnees | Basse | Majeur |\n\n**Reference** : CWE-20 - Improper Input Validation",
      "how": "## Comment corriger\n\n### Solution recommandee\n\nAjouter une validation stricte des entrees au debut de la fonction.\n\n### Implementation\n\n```cpp\nclass InputValidator {\npublic:\n    static bool isValidUsername(const std::string& username) {\n        if (username.length() < 3 || username.length() > 32) return false;\n        \n        // Alphanumerique + underscore uniquement\n        return std::all_of(username.begin(), username.end(), [](char c) {\n            return std::isalnum(c) || c == '_';\n        });\n    }\n    \n    static bool isValidPassword(const std::string& password) {\n        if (password.length() < 8 || password.length() > 255) return false;\n        \n        // Pas de caracteres de controle\n        return std::none_of(password.begin(), password.end(), [](char c) {\n            return std::iscntrl(c);\n        });\n    }\n};\n\n// Dans Login::execute\nstd::optional<User> Login::execute(const std::string& username, \n                                    const std::string& password) {\n    if (!InputValidator::isValidUsername(username)) {\n        logger->warn(\"Invalid username format: length={}\", username.length());\n        return std::nullopt;\n    }\n    \n    if (!InputValidator::isValidPassword(password)) {\n        logger->warn(\"Invalid password format for user: {}\", username);\n        return std::nullopt;\n    }\n    \n    // ... reste du code\n}\n```\n\n### Validation\n\n- [ ] Username vide rejete\n- [ ] Username > 32 caracteres rejete\n- [ ] Password < 8 caracteres rejete\n- [ ] Caracteres speciaux dans username rejetes"
    },
    "ANA-001": {
      "where": "## Localisation du probleme\n\n**Fichier** : `src/common/protocol/Protocol.hpp`\n**Ligne** : 1-202 (fichier entier)\n**Module** : common/protocol\n\n### Contexte\n\nCe fichier header definit le protocole de communication entre le client et le serveur. Il contient les structures de messages, les types d'enum, et les fonctions de serialisation.\n\n### Analyse des dependances\n\n```cpp\n// Structures definies:\n- MessageType (enum)\n- Header\n- UDPHeader  \n- LoginMessage\n- RegisterMessage\n- MovePlayer\n\n// Inclus par:\n- TCPClient.cpp\n- TCPServer.cpp\n- UDPServer.cpp\n- Session.cpp\n- ... et 17 autres fichiers\n```\n\n### Impact\n\nToute modification de ce fichier impacte potentiellement 21+ fichiers. Un bug dans la serialisation peut casser toute la communication client-serveur.\n\n> **Note** : Aucun test unitaire ne couvre ce fichier critique.",
      "why": "## Pourquoi c'est un probleme\n\n### Description\n\nUn Single Point of Failure (SPOF) architectural signifie qu'une erreur dans ce fichier peut :\n- Casser la compatibilite client-serveur\n- Introduire des bugs dans tous les modules dependants\n- Rendre le debugging tres difficile\n- Bloquer le developpement en parallele\n\n### Diagramme de dependances\n\n```mermaid\ngraph TD\n    P[Protocol.hpp] --> TC[TCPClient]\n    P --> TS[TCPServer]\n    P --> US[UDPServer]\n    P --> UC[UDPClient]\n    P --> S1[Session]\n    P --> S2[Execute]\n    P --> |17+ autres| MORE[...]\n    \n    style P fill:#f96,stroke:#333\n    \n    subgraph \"Zone d'impact\"\n    TC\n    TS\n    US\n    UC\n    S1\n    S2\n    MORE\n    end\n```\n\n### Risques identifies\n\n| Risque | Probabilite | Impact |\n|--------|-------------|--------|\n| Regression lors de modification | Haute | Majeur |\n| Incompatibilite version | Moyenne | Critique |\n| Bug de serialisation | Moyenne | Critique |",
      "how": "## Comment corriger\n\n### Solution recommandee\n\nAjouter des tests unitaires exhaustifs et envisager une refactorisation modulaire.\n\n### Tests a ajouter\n\n```cpp\n// tests/protocol_tests.cpp\n\nTEST(HeaderTest, SerializationRoundTrip) {\n    Header original{.isAuthenticated = true, .type = 0x0010, .payload_size = 100};\n    \n    uint8_t buffer[Header::WIRE_SIZE];\n    original.to_bytes(buffer);\n    \n    auto parsed = Header::from_bytes(buffer, Header::WIRE_SIZE);\n    ASSERT_TRUE(parsed.has_value());\n    EXPECT_EQ(parsed->isAuthenticated, original.isAuthenticated);\n    EXPECT_EQ(parsed->type, original.type);\n    EXPECT_EQ(parsed->payload_size, original.payload_size);\n}\n\nTEST(LoginMessageTest, SerializationRoundTrip) {\n    LoginMessage original;\n    std::strcpy(original.username, \"testuser\");\n    std::strcpy(original.password, \"testpass\");\n    \n    uint8_t buffer[LoginMessage::WIRE_SIZE];\n    original.to_bytes(buffer);\n    \n    auto parsed = LoginMessage::from_bytes(buffer, LoginMessage::WIRE_SIZE);\n    ASSERT_TRUE(parsed.has_value());\n    EXPECT_STREQ(parsed->username, original.username);\n    EXPECT_STREQ(parsed->password, original.password);\n}\n```\n\n### Refactorisation optionnelle\n\n```cpp\n// Separer en fichiers:\n// - protocol/Header.hpp\n// - protocol/Messages.hpp  \n// - protocol/Serialization.hpp\n// - protocol/Types.hpp\n```\n\n### Validation\n\n- [ ] Tests unitaires pour chaque structure\n- [ ] Tests de compatibilite endianness\n- [ ] Tests avec donnees invalides (fuzzing)\n- [ ] Documentation du format de protocole"
    },
    "ANA-002": {
      "where": "## Localisation du probleme\n\n**Fichier** : `src/client/src/network/TCPClient.cpp`\n**Ligne** : 1-320 (fichier entier)\n**Classe** : `TCPClient`\n\n### Contexte\n\nCette classe gere toute la communication TCP du client : connexion, deconnexion, envoi, reception, et parsing des messages.\n\n### Metriques de complexite\n\n| Metrique | Valeur | Seuil recommande |\n|----------|--------|------------------|\n| Complexite cyclomatique | 27 | 10 |\n| Lignes de code | 320 | 200 |\n| Fonctions | 15 | - |\n| Conditions imbriquees | 4 niveaux | 2 |\n\n### Code complexe identifie\n\n```cpp\nvoid TCPClient::handleRead(const boost::system::error_code &error, std::size_t bytes) {\n    if (!error) {\n        _accumulator.insert(...);\n        while (_accumulator.size() >= Header::WIRE_SIZE) {\n            auto headOpt = Header::from_bytes(...);\n            if (!headOpt) {\n                break;\n            }\n            Header head = *headOpt;\n            if (_accumulator.size() < totalSize) {\n                break;\n            }\n            if (head.type == static_cast<uint16_t>(MessageType::HeartBeat)) {\n                // ...\n            }\n            if (head.type == static_cast<uint16_t>(MessageType::Login)) {\n                // ...\n            }\n            else if (head.type == static_cast<uint16_t>(MessageType::Register)) {\n                // ...\n            }\n            // ... 4 niveaux d'imbrication\n        }\n    } else {\n        // ...\n    }\n}\n```",
      "why": "## Pourquoi c'est un probleme\n\n### Description\n\nUne complexite cyclomatique de 27 (seuil: 10) indique un code difficile a :\n- **Tester** : 27 chemins d'execution differents\n- **Comprendre** : Trop de branches conditionnelles\n- **Maintenir** : Chaque modification risque des regressions\n- **Debugger** : Difficile de suivre le flux\n\n### Visualisation de la complexite\n\n```mermaid\nmindmap\n  root((TCPClient.cpp))\n    handleRead\n      if !error\n        while accumulator\n          if headOpt\n            if size < total\n            if HeartBeat\n            if Login\n            else Register\n      else error\n        if eof\n        else other\n    handleConnect\n      if !error\n      else error\n    disconnect\n      if !connected\n      else ...\n```\n\n### Risques identifies\n\n| Risque | Probabilite | Impact |\n|--------|-------------|--------|\n| Bug lors de modification | Haute | Majeur |\n| Tests insuffisants | Certaine | Moyen |\n| Temps de debug eleve | Haute | Moyen |",
      "how": "## Comment corriger\n\n### Solution recommandee\n\nExtraire la logique en fonctions specialisees. Utiliser le pattern Strategy ou Command pour le dispatch des messages.\n\n### Avant / Apres\n\n**Avant (complexe)** :\n```cpp\nvoid handleRead(...) {\n    if (!error) {\n        while (...) {\n            if (head.type == Login) { ... }\n            else if (head.type == Register) { ... }\n            else if (head.type == HeartBeat) { ... }\n        }\n    }\n}\n```\n\n**Apres (refactorise)** :\n```cpp\nclass MessageHandler {\npublic:\n    virtual void handle(const Header& head, TCPClient& client) = 0;\n};\n\nclass LoginHandler : public MessageHandler {\n    void handle(const Header& head, TCPClient& client) override {\n        client.sendLoginData(client.getPendingUsername(), \n                            client.getPendingPassword());\n    }\n};\n\n// Dans TCPClient\nstd::unordered_map<MessageType, std::unique_ptr<MessageHandler>> _handlers;\n\nvoid handleRead(...) {\n    if (error) { handleReadError(error); return; }\n    \n    processAccumulator();\n}\n\nvoid processAccumulator() {\n    while (auto msg = tryParseMessage()) {\n        dispatchMessage(*msg);\n    }\n}\n\nvoid dispatchMessage(const Header& head) {\n    auto it = _handlers.find(static_cast<MessageType>(head.type));\n    if (it != _handlers.end()) {\n        it->second->handle(head, *this);\n    }\n}\n```\n\n### Validation\n\n- [ ] Complexite de chaque fonction <= 10\n- [ ] Tests unitaires pour chaque handler\n- [ ] Couverture de code >= 80%"
    },
    "ANA-003": {
      "where": "## Localisation du probleme\n\n**Fichier** : `src/ECS/Registry.hpp`\n**Ligne** : 118\n**Classe** : `Registry`\n\n### Contexte\n\nLe Registry est le coeur du systeme ECS (Entity Component System). Il stocke tous les pools de composants pour chaque type.\n\n### Code problematique\n\n```cpp\nclass Registry {\n    // ...\nprivate:\n    IComponentPool *m_pool_list[UINT16_MAX]{nullptr};  // 65535 pointeurs!\n};\n```\n\n### Calcul de memoire\n\n```\nUINT16_MAX = 65535\nsizeof(IComponentPool*) = 8 bytes (64-bit)\n\nAllocation statique = 65535 * 8 = 524,280 bytes = 512 KB\n```\n\n### Analyse\n\nChaque instance de `Registry` alloue statiquement 512KB de memoire, meme si seulement 10 types de composants sont utilises. Sur un systeme embarque ou avec plusieurs registries, cela peut devenir problematique.\n\n> **Note** : `UINT16_MAX` comme taille suggere une sur-estimation des besoins reels.",
      "why": "## Pourquoi c'est un probleme\n\n### Description\n\nL'allocation statique de 512KB par Registry pose plusieurs problemes :\n- **Gaspillage memoire** : Utilisation typique < 100 types\n- **Stack overflow** : Si Registry sur la pile\n- **Cache inefficace** : Tableau sparse mal utilise\n- **Scalabilite** : Multiple registries = multiple 512KB\n\n### Comparaison\n\n| Approche | 10 types | 100 types | 1000 types |\n|----------|----------|-----------|------------|\n| Array fixe UINT16_MAX | 512 KB | 512 KB | 512 KB |\n| std::unordered_map | 400 B | 4 KB | 40 KB |\n| std::vector | 80 B | 800 B | 8 KB |\n\n### Risques identifies\n\n| Risque | Probabilite | Impact |\n|--------|-------------|--------|\n| Gaspillage memoire | Certaine | Mineur |\n| Stack overflow | Moyenne | Majeur |\n| Performance cache | Basse | Mineur |",
      "how": "## Comment corriger\n\n### Solution recommandee\n\nRemplacer le tableau statique par une structure dynamique comme `std::unordered_map`.\n\n### Avant / Apres\n\n**Avant (allocation fixe)** :\n```cpp\nclass Registry {\nprivate:\n    IComponentPool *m_pool_list[UINT16_MAX]{nullptr};  // 512KB\n};\n```\n\n**Apres (allocation dynamique)** :\n```cpp\nclass Registry {\nprivate:\n    std::unordered_map<uint16_t, std::unique_ptr<IComponentPool>> m_pools;\n};\n```\n\n### Adaptation des methodes\n\n```cpp\nbool componentExists(uint16_t type_id) {\n    return m_pools.contains(type_id);\n}\n\ntemplate <ComponentType T>\nbool registerComponent() {\n    uint16_t type_id = ComponentTypeId::get<T>();\n    if (componentExists(type_id)) return false;\n    \n    m_pools[type_id] = std::make_unique<ComponentPool<T>>();\n    return true;\n}\n\ntemplate <ComponentType T>\nComponentPool<T>& getPool() {\n    uint16_t type_id = ComponentTypeId::get<T>();\n    auto it = m_pools.find(type_id);\n    if (it == m_pools.end()) {\n        throw ERROR::UnregisteredComponent(typeid(T).name());\n    }\n    return *static_cast<ComponentPool<T>*>(it->second.get());\n}\n```\n\n### Validation\n\n- [ ] sizeof(Registry) < 100 bytes\n- [ ] Tests ECS passent toujours\n- [ ] Performance benchmark similaire\n- [ ] Pas de memory leak (valgrind)"
    },
    "REV-002": {
      "where": "## Localisation du probleme\n\n**Fichier** : `src/server/application/use_cases/auth/Login.cpp` (et 9 autres)\n**Ligne** : 11\n**Symbole** : `IUserRespository`\n\n### Contexte\n\nL'interface repository pour les utilisateurs contient une faute de frappe dans son nom : \"Respository\" au lieu de \"Repository\".\n\n### Code problematique\n\n```cpp\n// Login.cpp ligne 11\nLogin::Login(std::shared_ptr<IUserRespository> userRepository) \n    : _userRespository(userRepository) {}\n//                     ^^^^^^^^^^^^\n//                     Typo: \"Resp\" au lieu de \"Repo\"\n```\n\n### Fichiers impactes\n\n1. `IUserRespository.hpp` (definition)\n2. `Login.cpp`\n3. `Register.cpp`\n4. `ExecuteAuth.cpp`\n5. `MongoDBUserRepository.cpp`\n6. `Session.cpp`\n7. `TCPServer.cpp`\n8. `GameBootstrap.hpp`\n9. `Command.hpp`\n10. `Execute.hpp`",
      "why": "## Pourquoi c'est un probleme\n\n### Description\n\nUn typo dans un nom d'interface cause :\n- **Confusion** : Les developpeurs cherchent \"Repository\" et ne trouvent pas\n- **Inconsistance** : Melange de conventions dans le codebase\n- **Documentation** : Difficile a documenter correctement\n- **Onboarding** : Nouveaux developpeurs perdus\n\n### Impact\n\n```mermaid\ngraph TD\n    A[IUserRespository typo] --> B[10 fichiers impactes]\n    B --> C[Recherche difficile]\n    B --> D[Auto-completion cassee]\n    B --> E[Documentation incorrecte]\n    style A fill:#f96,stroke:#333\n```\n\n### Risques identifies\n\n| Risque | Probabilite | Impact |\n|--------|-------------|--------|\n| Confusion developpeurs | Certaine | Mineur |\n| Temps perdu | Haute | Mineur |\n| Erreurs de refactoring | Moyenne | Mineur |",
      "how": "## Comment corriger\n\n### Solution recommandee\n\nRenommer `IUserRespository` en `IUserRepository` dans tous les fichiers.\n\n### Commande de renommage\n\n```bash\n# Trouver tous les fichiers concernes\ngrep -rn \"IUserRespository\" src/\n\n# Renommer avec sed\nfind src/ -type f \\( -name \"*.cpp\" -o -name \"*.hpp\" \\) \\\n    -exec sed -i 's/IUserRespository/IUserRepository/g' {} +\n\n# Renommer le fichier header\nmv src/server/include/application/ports/out/IUserRespository.hpp \\\n   src/server/include/application/ports/out/IUserRepository.hpp\n\n# Mettre a jour les includes\nfind src/ -type f \\( -name \"*.cpp\" -o -name \"*.hpp\" \\) \\\n    -exec sed -i 's/IUserRespository.hpp/IUserRepository.hpp/g' {} +\n```\n\n### Verification\n\n```bash\n# Verifier qu'aucune occurrence ne reste\ngrep -rn \"Respository\" src/\n# Devrait retourner 0 resultat\n\n# Compiler pour verifier\n./scripts/compile.sh\n```\n\n### Validation\n\n- [ ] `grep -rn \"Respository\" src/` retourne 0 resultat\n- [ ] Compilation reussie\n- [ ] Tests passent\n- [ ] Commit avec message explicite"
    }
  }
}
